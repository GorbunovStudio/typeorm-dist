{"version":3,"sources":["../browser/src/persistence/SubjectOperationExecutor.ts"],"names":[],"mappings":"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","file":"SubjectOperationExecutor.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\r\nimport {JunctionInsert, JunctionRemove, Subject} from \"./Subject\";\r\nimport {OrmUtils} from \"../util/OrmUtils\";\r\nimport {EntityManager} from \"../entity-manager/EntityManager\";\r\nimport {PromiseUtils} from \"../util/PromiseUtils\";\r\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {EmbeddedMetadata} from \"../metadata/EmbeddedMetadata\";\r\nimport {Broadcaster} from \"../subscriber/Broadcaster\";\r\n\r\n/**\r\n * Executes all database operations (inserts, updated, deletes) that must be executed\r\n * with given persistence subjects.\r\n */\r\nexport class SubjectOperationExecutor {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * All subjects that needs to be operated.\r\n     */\r\n    protected allSubjects: Subject[];\r\n\r\n    /**\r\n     * Subjects that must be inserted.\r\n     */\r\n    protected insertSubjects: Subject[];\r\n\r\n    /**\r\n     * Subjects that must be updated.\r\n     */\r\n    protected updateSubjects: Subject[];\r\n\r\n    /**\r\n     * Subjects that must be removed.\r\n     */\r\n    protected removeSubjects: Subject[];\r\n\r\n    /**\r\n     * Subjects which relations should be updated.\r\n     */\r\n    protected relationUpdateSubjects: Subject[];\r\n\r\n    protected broadcaster: Broadcaster;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(protected connection: Connection,\r\n                protected transactionEntityManager: EntityManager,\r\n                protected queryRunner: QueryRunner,\r\n                subjects: Subject[]) {\r\n\r\n        /*subjects.forEach(subject => {\r\n         console.log(subject.entity);\r\n         console.log(\"mustBeInserted: \", subject.mustBeInserted);\r\n         console.log(\"mustBeUpdated: \", subject.mustBeUpdated);\r\n         console.log(\"mustBeRemoved: \", subject.mustBeRemoved);\r\n         });*/\r\n\r\n        // validate all subjects first\r\n        subjects.forEach(subject => subject.validate());\r\n\r\n        // set class properties for easy use\r\n        this.allSubjects = subjects;\r\n        this.insertSubjects = subjects.filter(subject => subject.mustBeInserted);\r\n        this.updateSubjects = subjects.filter(subject => subject.mustBeUpdated);\r\n        this.removeSubjects = subjects.filter(subject => subject.mustBeRemoved);\r\n        this.relationUpdateSubjects = subjects.filter(subject => subject.hasRelationUpdates);\r\n\r\n        this.broadcaster = new Broadcaster(this.connection);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    areExecutableOperations(): boolean {\r\n        return this.insertSubjects.length > 0 ||\r\n            this.updateSubjects.length > 0 ||\r\n            this.removeSubjects.length > 0 ||\r\n            this.relationUpdateSubjects.length > 0 ||\r\n            this.allSubjects.some(subject => subject.junctionInserts.length > 0) ||\r\n            this.allSubjects.some(subject => subject.junctionRemoves.length > 0);\r\n    }\r\n\r\n    /**\r\n     * Executes all operations over given array of subjects.\r\n     * Executes queries using given query runner.\r\n     */\r\n    async execute(): Promise<void> {\r\n\r\n        // broadcast \"before\" events before we start updating\r\n        await this.broadcaster.broadcastBeforeEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects);\r\n\r\n        // since events can trigger some internal changes (for example update depend property) we need to perform some re-computations here\r\n        this.updateSubjects.forEach(subject => subject.recompute());\r\n\r\n        await this.executeInsertOperations();\r\n        await this.executeInsertClosureTableOperations();\r\n        await this.executeInsertJunctionsOperations();\r\n        await this.executeRemoveJunctionsOperations();\r\n        await this.executeUpdateOperations();\r\n        await this.executeUpdateRelations();\r\n        await this.executeRemoveOperations();\r\n\r\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\r\n        await this.updateSpecialColumnsInPersistedEntities();\r\n\r\n        // finally broadcast \"after\" events\r\n        // todo: THIS SHOULD NOT BE TRUTH: note that we are broadcasting events after commit because we want to have ids of the entities inside them to be available in subscribers\r\n        await this.broadcaster.broadcastAfterEventsForAll(this.transactionEntityManager, this.insertSubjects, this.updateSubjects, this.removeSubjects);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Insertion\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Executes insert operations.\r\n     *\r\n     * For insertion we separate two groups of entities:\r\n     * - first group of entities are entities which do not have any relations\r\n     *      or entities which do not have any non-nullable relation\r\n     * - second group of entities are entities which does have non-nullable relations\r\n     *\r\n     * Insert process of the entities from the first group which can only have nullable relations are actually a two-step process:\r\n     * - first we insert entities without their relations, explicitly left them NULL\r\n     * - later we update inserted entity once again with id of the object inserted with it\r\n     *\r\n     * Yes, two queries are being executed, but this is by design.\r\n     * There is no better way to solve this problem and others at the same time.\r\n     *\r\n     * Insert process of the entities from the second group which can have only non nullable relations is a single-step process:\r\n     * - we simply insert all entities and get into attention all its dependencies which were inserted in the first group\r\n     */\r\n    private async executeInsertOperations(): Promise<void> {\r\n\r\n        // separate insert entities into groups:\r\n\r\n        // TODO: current ordering mechanism is bad. need to create a correct order in which entities should be persisted, need to build a dependency graph\r\n\r\n        // first group of subjects are subjects without any non-nullable column\r\n        // we need to insert first such entities because second group entities may rely on those entities.\r\n        const firstInsertSubjects = this.insertSubjects.filter(subject => !subject.metadata.hasNonNullableRelations);\r\n\r\n        // second group - are all other subjects\r\n        // since in this group there are non nullable columns, some of them may depend on value of the\r\n        // previously inserted entity (which only can be entity with all nullable columns)\r\n        const secondInsertSubjects = this.insertSubjects.filter(subject => subject.metadata.hasNonNullableRelations);\r\n\r\n        // note: these operations should be executed in sequence, not in parallel\r\n        // because second group depend of obtained data from the first group\r\n        await Promise.all(firstInsertSubjects.map(subject => this.insert(subject, [])));\r\n        await Promise.all(secondInsertSubjects.map(subject => this.insert(subject, firstInsertSubjects)));\r\n\r\n        // we need to update relation ids of the newly inserted objects (where we inserted NULLs in relations)\r\n        // once we inserted all entities, we need to update relations which were bind to inserted entities.\r\n        // For example we have a relation many-to-one Post<->Category. Relation is nullable.\r\n        // New category was set to the new post and post where persisted.\r\n        // Here this method executes two inserts: one for post, one for category,\r\n        // but category in post is inserted with \"null\".\r\n        // now we need to update post table - set category with a newly persisted category id.\r\n        const updatePromises: Promise<any>[] = [];\r\n        firstInsertSubjects.forEach(subject => {\r\n\r\n            // first update relations with join columns (one-to-one owner and many-to-one relations)\r\n            const updateOptions: ObjectLiteral = {};\r\n            subject.metadata.relationsWithJoinColumns.forEach(relation => {\r\n                relation.joinColumns.forEach(joinColumn => {\r\n                    const referencedColumn = joinColumn.referencedColumn!;\r\n                    const relatedEntity = relation.getEntityValue(subject.entity);\r\n\r\n                    // if relation value is not set then nothing to do here\r\n                    if (!relatedEntity)\r\n                        return;\r\n\r\n                    // check if relation reference column is a relation\r\n                    let relationId: any;\r\n                    const columnRelation = relation.inverseEntityMetadata.findRelationWithPropertyPath(joinColumn.referencedColumn!.propertyPath);\r\n                    if (columnRelation) { // if referenced column is a relation\r\n                        const insertSubject = this.insertSubjects.find(insertedSubject => insertedSubject.entity === referencedColumn.getEntityValue(relatedEntity));\r\n\r\n                        // if this relation was just inserted\r\n                        if (insertSubject) {\r\n\r\n                            // check if we have this relation id already\r\n                            relationId = columnRelation.getEntityValue(referencedColumn.getEntityValue(relatedEntity));\r\n                            if (!relationId) {\r\n\r\n                                // if we don't have relation id then use special values\r\n                                if (referencedColumn.isGenerated && insertSubject.generatedMap)\r\n                                    relationId = referencedColumn.getEntityValue(insertSubject.generatedMap);\r\n                                // todo: handle other special types too\r\n                            }\r\n                        }\r\n\r\n                    } else { // if referenced column is a simple non relational column\r\n                        const insertSubject = this.insertSubjects.find(insertedSubject => insertedSubject.entity === relatedEntity);\r\n\r\n                        // if this relation was just inserted\r\n                        if (insertSubject) {\r\n\r\n                            // check if we have this relation id already\r\n                            relationId = referencedColumn.getEntityValue(relatedEntity);\r\n                            if (!relationId) {\r\n\r\n                                // if we don't have relation id then use special values\r\n                                if (referencedColumn.isGenerated && insertSubject.generatedMap)\r\n                                    relationId = referencedColumn.getEntityValue(insertSubject.generatedMap);\r\n                                // todo: handle other special types too\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if (relationId) {\r\n                        updateOptions[joinColumn.databaseName] = relationId;\r\n                    }\r\n\r\n                });\r\n            });\r\n\r\n            // if we found relations which we can update - then update them\r\n            if (Object.keys(updateOptions).length > 0 /*&& subject.hasEntity*/) {\r\n                // const relatedEntityIdMap = subject.getPersistedEntityIdMap; // todo: this works incorrectly\r\n\r\n                const columns = subject.metadata.parentEntityMetadata ? subject.metadata.primaryColumns : subject.metadata.primaryColumns;\r\n                const conditions: ObjectLiteral = {};\r\n\r\n                columns.forEach(column => {\r\n                    const entityValue = column.getEntityValue(subject.entity);\r\n\r\n                    // if entity id is a relation, then extract referenced column from that relation\r\n                    const columnRelation = subject.metadata.relations.find(relation => relation.propertyName === column.propertyName);\r\n\r\n                    if (entityValue && columnRelation) { // not sure if we need handle join column from inverse side\r\n                        columnRelation.joinColumns.forEach(joinColumn => {\r\n                            let relationIdOfEntityValue = entityValue[joinColumn.referencedColumn!.propertyName];\r\n                            if (!relationIdOfEntityValue) {\r\n                                const entityValueInsertSubject = this.insertSubjects.find(subject => subject.entity === entityValue);\r\n                                if (entityValueInsertSubject) {\r\n                                    if (joinColumn.referencedColumn!.isGenerated && entityValueInsertSubject.generatedMap)\r\n                                        relationIdOfEntityValue = joinColumn.referencedColumn!.getEntityValue(entityValueInsertSubject.generatedMap);\r\n                                }\r\n                            }\r\n                            if (relationIdOfEntityValue) {\r\n                                conditions[column.databaseName] = relationIdOfEntityValue;\r\n                            }\r\n                        });\r\n\r\n                    } else {\r\n                        if (entityValue) {\r\n                            conditions[column.databaseName] = entityValue;\r\n                        } else {\r\n                            if (subject.generatedMap)\r\n                                conditions[column.databaseName] = column.getEntityValue(subject.generatedMap);\r\n                        }\r\n                    }\r\n                });\r\n                if (!Object.keys(conditions).length)\r\n                    return;\r\n\r\n\r\n\r\n                const updatePromise = this.queryRunner.update(subject.metadata.tablePath, updateOptions, conditions);\r\n                updatePromises.push(updatePromise);\r\n            }\r\n\r\n            // we need to update relation ids if newly inserted objects are used from inverse side in one-to-many inverse relation\r\n            // we also need to update relation ids if newly inserted objects are used from inverse side in one-to-one inverse relation\r\n            const oneToManyAndOneToOneNonOwnerRelations = subject.metadata.oneToManyRelations.concat(subject.metadata.oneToOneRelations.filter(relation => !relation.isOwning));\r\n            // console.log(oneToManyAndOneToOneNonOwnerRelations);\r\n            subject.metadata.extractRelationValuesFromEntity(subject.entity, oneToManyAndOneToOneNonOwnerRelations)\r\n                .forEach(([relation, subRelatedEntity, inverseEntityMetadata]) => {\r\n                    relation.inverseRelation!.joinColumns.forEach(joinColumn => {\r\n\r\n                        const referencedColumn = joinColumn.referencedColumn!;\r\n                        const columns = inverseEntityMetadata.parentEntityMetadata ? inverseEntityMetadata.primaryColumns : inverseEntityMetadata.primaryColumns;\r\n                        const conditions: ObjectLiteral = {};\r\n\r\n                        columns.forEach(column => {\r\n                            const entityValue = column.getEntityValue(subRelatedEntity);\r\n\r\n                            // if entity id is a relation, then extract referenced column from that relation\r\n                            const columnRelation = inverseEntityMetadata.relations.find(relation => relation.propertyName === column.propertyName);\r\n\r\n                            if (entityValue && columnRelation) { // not sure if we need handle join column from inverse side\r\n                                columnRelation.joinColumns.forEach(columnRelationJoinColumn => {\r\n                                    let relationIdOfEntityValue = entityValue[columnRelationJoinColumn.referencedColumn!.propertyName];\r\n                                    if (!relationIdOfEntityValue) {\r\n                                        const entityValueInsertSubject = this.insertSubjects.find(subject => subject.entity === entityValue);\r\n                                        if (entityValueInsertSubject) {\r\n                                            if (columnRelationJoinColumn.referencedColumn!.isGenerated && entityValueInsertSubject.generatedMap) {\r\n                                                relationIdOfEntityValue = columnRelationJoinColumn.referencedColumn!.getEntityValue(entityValueInsertSubject.generatedMap);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    if (relationIdOfEntityValue) {\r\n                                        conditions[column.databaseName] = relationIdOfEntityValue;\r\n                                    }\r\n                                });\r\n\r\n                            } else {\r\n                                const entityValueInsertSubject = this.insertSubjects.find(subject => subject.entity === subRelatedEntity);\r\n                                if (entityValue) {\r\n                                    conditions[column.databaseName] = entityValue;\r\n                                } else {\r\n                                    if (entityValueInsertSubject && entityValueInsertSubject.generatedMap)\r\n                                        conditions[column.databaseName] = column.getEntityValue(entityValueInsertSubject.generatedMap);\r\n                                }\r\n                            }\r\n                        });\r\n\r\n                        if (!Object.keys(conditions).length)\r\n                            return;\r\n\r\n                        const updateOptions: ObjectLiteral = {};\r\n                        const columnRelation = relation.inverseEntityMetadata.relations.find(rel => rel.propertyName === referencedColumn.propertyName);\r\n                        const columnValue = referencedColumn.getEntityValue(subject.entity);\r\n                        if (columnRelation) {\r\n                            let id = columnRelation.getEntityValue(columnValue);\r\n                            if (!id) {\r\n                                const insertSubject = this.insertSubjects.find(subject => subject.entity === columnValue);\r\n                                if (insertSubject) {\r\n                                    if (insertSubject.generatedMap)\r\n                                        id = referencedColumn.getEntityValue(insertSubject.generatedMap);\r\n                                }\r\n                            }\r\n                            updateOptions[joinColumn.databaseName] = id;\r\n                        } else {\r\n                            const generatedColumnValue = subject.generatedMap ? referencedColumn.getEntityValue(subject.generatedMap) : undefined;\r\n                            updateOptions[joinColumn.databaseName] = columnValue || generatedColumnValue;\r\n                        }\r\n\r\n                        const updatePromise = this.queryRunner.update(relation.inverseEntityMetadata.tablePath, updateOptions, conditions);\r\n                        updatePromises.push(updatePromise);\r\n\r\n                    });\r\n                });\r\n\r\n        });\r\n\r\n        await Promise.all(updatePromises);\r\n\r\n        // todo: make sure to search in all insertSubjects during updating too if updated entity uses links to the newly persisted entity\r\n    }\r\n\r\n    /**\r\n     * Inserts an entity from the given insert operation into the database.\r\n     * If entity has an generated column, then after saving new generated value will be stored to the InsertOperation.\r\n     * If entity uses class-table-inheritance, then multiple inserts may by performed to save all entities.\r\n     */\r\n    private async insert(subject: Subject, alreadyInsertedSubjects: Subject[]): Promise<any> {\r\n\r\n        const parentEntityMetadata = subject.metadata.parentEntityMetadata;\r\n        const metadata = subject.metadata;\r\n        const entity = subject.entity;\r\n        let insertResult: any, parentGeneratedId: any;\r\n\r\n        // if entity uses class table inheritance then we need to separate entity into sub values that will be inserted into multiple tables\r\n        if (metadata.isClassTableChild) { // todo: with current implementation inheritance of multiple class table children will not work\r\n\r\n            // first insert entity values into parent class table\r\n            const parentValuesMap = this.collectColumnsAndValues(parentEntityMetadata, entity, subject.date, undefined, metadata.discriminatorValue, alreadyInsertedSubjects, \"insert\");\r\n            insertResult = parentGeneratedId = await this.queryRunner.insert(parentEntityMetadata.tablePath, parentValuesMap);\r\n\r\n            // second insert entity values into child class table\r\n            const childValuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, insertResult.generatedMap[parentEntityMetadata.primaryColumns[0].propertyName], undefined, alreadyInsertedSubjects, \"insert\");\r\n            const secondGeneratedId = await this.queryRunner.insert(metadata.tablePath, childValuesMap);\r\n            if (!insertResult && secondGeneratedId) insertResult = secondGeneratedId;\r\n\r\n        } else { // in the case when class table inheritance is not used\r\n\r\n            const valuesMap = this.collectColumnsAndValues(metadata, entity, subject.date, undefined, undefined, alreadyInsertedSubjects, \"insert\");\r\n            // console.log(\"valuesMap\", valuesMap);\r\n            insertResult = await this.queryRunner.insert(metadata.tablePath, valuesMap);\r\n        }\r\n\r\n        if (parentGeneratedId)\r\n            subject.parentGeneratedId = parentGeneratedId.generatedMap[parentEntityMetadata.primaryColumns[0].propertyName];\r\n\r\n        // todo: better if insert method will return object with all generated ids, object id, etc.\r\n        if (insertResult.generatedMap)\r\n            subject.generatedMap = insertResult.generatedMap;\r\n    }\r\n\r\n    private collectColumns(columns: ColumnMetadata[], entity: ObjectLiteral, object: ObjectLiteral, operation: \"insert\"|\"update\") {\r\n        columns.forEach(column => {\r\n            if (column.isVirtual || column.isParentId || column.isDiscriminator)\r\n                return;\r\n            if (operation === \"update\" && column.isReadonly)\r\n                return;\r\n\r\n            const value = entity[column.propertyName];\r\n            if (value === undefined)\r\n                return;\r\n\r\n            object[column.databaseNameWithoutPrefixes] = this.connection.driver.preparePersistentValue(value, column); // todo: maybe preparePersistentValue is not responsibility of this class\r\n        });\r\n    }\r\n\r\n    private collectEmbeds(embed: EmbeddedMetadata, entity: ObjectLiteral, object: ObjectLiteral, operation: \"insert\"|\"update\") {\r\n\r\n        if (embed.isArray) {\r\n            if (entity[embed.propertyName] instanceof Array) {\r\n                if (!object[embed.prefix])\r\n                    object[embed.prefix] = [];\r\n\r\n                entity[embed.propertyName].forEach((subEntity: any, index: number) => {\r\n                    if (!object[embed.prefix][index])\r\n                        object[embed.prefix][index] = {};\r\n                    this.collectColumns(embed.columns, subEntity, object[embed.prefix][index], operation);\r\n                    embed.embeddeds.forEach(childEmbed => this.collectEmbeds(childEmbed, subEntity, object[embed.prefix][index], operation));\r\n                });\r\n            }\r\n        } else {\r\n            if (entity[embed.propertyName] !== undefined) {\r\n                if (!object[embed.prefix])\r\n                    object[embed.prefix] = {};\r\n                this.collectColumns(embed.columns, entity[embed.propertyName], object[embed.prefix], operation);\r\n                embed.embeddeds.forEach(childEmbed => this.collectEmbeds(childEmbed, entity[embed.propertyName], object[embed.prefix], operation));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Collects columns and values for the insert operation.\r\n     */\r\n    private collectColumnsAndValues(metadata: EntityMetadata, entity: ObjectLiteral, date: Date, parentIdColumnValue: any, discriminatorValue: any, alreadyInsertedSubjects: Subject[], operation: \"insert\"|\"update\"): ObjectLiteral {\r\n\r\n        const values: ObjectLiteral = {};\r\n\r\n        if (this.connection.driver instanceof MongoDriver) {\r\n            this.collectColumns(metadata.ownColumns, entity, values, operation);\r\n            metadata.embeddeds.forEach(embed => this.collectEmbeds(embed, entity, values, operation));\r\n\r\n        } else {\r\n            metadata.columns.forEach(column => {\r\n                if (column.isVirtual || column.isParentId || column.isDiscriminator)\r\n                    return;\r\n\r\n                const value = column.getEntityValue(entity);\r\n                if (value === undefined)\r\n                    return;\r\n\r\n                values[column.databaseName] = this.connection.driver.preparePersistentValue(value, column); // todo: maybe preparePersistentValue is not responsibility of this class\r\n            });\r\n        }\r\n\r\n        metadata.relationsWithJoinColumns.forEach(relation => {\r\n            relation.joinColumns.forEach(joinColumn => {\r\n\r\n                let relationValue: any;\r\n                const value = relation.getEntityValue(entity);\r\n\r\n                if (value) {\r\n                    // if relation value is stored in the entity itself then use it from there\r\n                    const relationId = joinColumn.referencedColumn!.getEntityValue(value); // relation.getInverseEntityRelationId(value); // todo: check it\r\n                    if (relationId) {\r\n                        relationValue = relationId;\r\n                    }\r\n\r\n                    // otherwise try to find relational value from just inserted subjects\r\n                    const alreadyInsertedSubject = alreadyInsertedSubjects.find(insertedSubject => {\r\n                        return insertedSubject.entity === value;\r\n                    });\r\n                    if (alreadyInsertedSubject) {\r\n                        const referencedColumn = joinColumn.referencedColumn!;\r\n                        // if join column references to the primary generated column then seek in the newEntityId of the insertedSubject\r\n                        if (referencedColumn.referencedColumn && referencedColumn.referencedColumn!.isGenerated) {\r\n                            if (referencedColumn.isParentId) {\r\n                                relationValue = alreadyInsertedSubject.parentGeneratedId;\r\n                            }\r\n                            // todo: what if reference column is not generated?\r\n                            // todo: what if reference column is not related to table inheritance?\r\n                        }\r\n\r\n                        if (referencedColumn.isGenerated && alreadyInsertedSubject.generatedMap)\r\n                            relationValue = referencedColumn.getEntityValue(alreadyInsertedSubject.generatedMap);\r\n                        // if it references to create or update date columns\r\n                        if (referencedColumn.isCreateDate || referencedColumn.isUpdateDate)\r\n                            relationValue = this.connection.driver.preparePersistentValue(alreadyInsertedSubject.date, referencedColumn);\r\n                        // if it references to version column\r\n                        if (referencedColumn.isVersion)\r\n                            relationValue = this.connection.driver.preparePersistentValue(1, referencedColumn);\r\n                    }\r\n                } else if (relation.inverseRelation) {\r\n                    const inverseSubject = this.allSubjects.find(subject => {\r\n                        if (!subject.hasEntity || subject.entityTarget !== relation.inverseRelation!.target)\r\n                            return false;\r\n\r\n                        const inverseRelationValue = relation.inverseRelation!.getEntityValue(subject.entity);\r\n                        if (inverseRelationValue) {\r\n                            if (inverseRelationValue instanceof Array) {\r\n                                return inverseRelationValue.find(subValue => subValue === subValue);\r\n                            } else {\r\n                                return inverseRelationValue === entity;\r\n                            }\r\n                        }\r\n                    });\r\n                    if (inverseSubject && joinColumn.referencedColumn!.getEntityValue(inverseSubject.entity)) {\r\n                        relationValue = joinColumn.referencedColumn!.getEntityValue(inverseSubject.entity);\r\n                    }\r\n                }\r\n\r\n                if (relationValue) {\r\n                    values[joinColumn.databaseName] = relationValue;\r\n                }\r\n\r\n            });\r\n        });\r\n\r\n        // add special column and value - date of creation\r\n        if (metadata.createDateColumn) {\r\n            const value = this.connection.driver.preparePersistentValue(date, metadata.createDateColumn);\r\n            values[metadata.createDateColumn.databaseName] = value;\r\n        }\r\n\r\n        // add special column and value - date of updating\r\n        if (metadata.updateDateColumn) {\r\n            const value = this.connection.driver.preparePersistentValue(date, metadata.updateDateColumn);\r\n            values[metadata.updateDateColumn.databaseName] = value;\r\n        }\r\n\r\n        // add special column and value - version column\r\n        if (metadata.versionColumn) {\r\n            const value = this.connection.driver.preparePersistentValue(1, metadata.versionColumn);\r\n            values[metadata.versionColumn.databaseName] = value;\r\n        }\r\n\r\n        // add special column and value - discriminator value (for tables using table inheritance)\r\n        if (metadata.discriminatorColumn) {\r\n            const value = this.connection.driver.preparePersistentValue(discriminatorValue || metadata.discriminatorValue, metadata.discriminatorColumn);\r\n            values[metadata.discriminatorColumn.databaseName] = value;\r\n        }\r\n\r\n        metadata.generatedColumns\r\n            .filter(column => column.generationStrategy === \"uuid\")\r\n            .forEach(column => {\r\n                if (column.isNullable && values[column.databaseName] === null)\r\n                    return;\r\n                const uuid = this.connection.driver.preparePersistentValue(\"\", column);\r\n                if (uuid && !values[column.databaseName])\r\n                    values[column.databaseName] = uuid;\r\n            });\r\n\r\n        // add special column and value - tree level and tree parents (for tree-type tables)\r\n        if (metadata.treeLevelColumn && metadata.treeParentRelation) {\r\n            const parentEntity = metadata.treeParentRelation.getEntityValue(entity);\r\n            const parentLevel = parentEntity ? (metadata.treeLevelColumn.getEntityValue(parentEntity) || 0) : 0;\r\n\r\n            values[metadata.treeLevelColumn.databaseName] = parentLevel + 1;\r\n        }\r\n\r\n        // add special column and value - parent id column (for tables using table inheritance)\r\n        if (metadata.parentEntityMetadata && metadata.parentIdColumns.length) { // todo: should be array of primary keys\r\n            values[metadata.parentIdColumns[0].databaseName] = parentIdColumnValue || metadata.parentEntityMetadata.primaryColumns[0].getEntityValue(entity);\r\n        }\r\n\r\n        return values;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Insertion into closure tables\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Inserts all given subjects into closure table.\r\n     */\r\n    private executeInsertClosureTableOperations(/*, updatesByRelations: Subject[]*/) { // todo: what to do with updatesByRelations\r\n        const promises = this.insertSubjects\r\n            .filter(subject => subject.metadata.isClosure)\r\n            .map(async subject => {\r\n                // const relationsUpdateMap = this.findUpdateOperationForEntity(updatesByRelations, insertSubjects, subject.entity);\r\n                // subject.treeLevel = await this.insertIntoClosureTable(subject, relationsUpdateMap);\r\n                await this.insertClosureTableValues(subject);\r\n            });\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * Inserts given subject into closure table.\r\n     */\r\n    private async insertClosureTableValues(subject: Subject): Promise<void> {\r\n        // todo: since closure tables do not support compose primary keys - throw an exception?\r\n        // todo: what if parent entity or parentEntityId is empty?!\r\n        const tablePath = subject.metadata.closureJunctionTable.tablePath;\r\n        const referencedColumn = subject.metadata.treeParentRelation!.joinColumns[0].referencedColumn!; // todo: check if joinColumn works\r\n        // todo: fix joinColumns[0] usage\r\n\r\n        let newEntityId = referencedColumn.getEntityValue(subject.entity);\r\n        if (!newEntityId && referencedColumn.isGenerated && subject.generatedMap) {\r\n            newEntityId = referencedColumn.getEntityValue(subject.generatedMap);\r\n            // we should not handle object id here because closure tables are not supported by mongodb driver.\r\n        } // todo: implement other special column types too\r\n\r\n        const parentEntity = subject.metadata.treeParentRelation!.getEntityValue(subject.entity);\r\n        let parentEntityId: any = 0; // zero is important\r\n        if (parentEntity) {\r\n            parentEntityId = referencedColumn.getEntityValue(parentEntity);\r\n            if (!parentEntityId && referencedColumn.isGenerated) {\r\n                const parentInsertedSubject = this.insertSubjects.find(subject => subject.entity === parentEntity);\r\n                // todo: throw exception if parentInsertedSubject is not set\r\n                if (parentInsertedSubject!.generatedMap)\r\n                    parentEntityId = referencedColumn.getEntityValue(parentInsertedSubject!.generatedMap!);\r\n            } // todo: implement other special column types too\r\n        }\r\n\r\n        // try to find parent entity id in some other entity that has this entity in its children\r\n        if (!parentEntityId) {\r\n            const parentSubject = this.allSubjects.find(allSubject => {\r\n                if (!allSubject.hasEntity || !allSubject.metadata.isClosure || !allSubject.metadata.treeChildrenRelation)\r\n                    return false;\r\n\r\n                const children = subject.metadata.treeChildrenRelation!.getEntityValue(allSubject.entity);\r\n                return children instanceof Array ? children.indexOf(subject.entity) !== -1 : false;\r\n            });\r\n\r\n            if (parentSubject) {\r\n                parentEntityId = referencedColumn.getEntityValue(parentSubject.entity);\r\n                if (!parentEntityId && parentSubject.generatedMap) { // if still not found then it means parent just inserted with generated column\r\n                    parentEntityId = referencedColumn.getEntityValue(parentSubject.generatedMap);\r\n                }\r\n            }\r\n        }\r\n\r\n        // if parent entity exist then insert a new row into closure table\r\n        subject.treeLevel = await this.queryRunner.insertIntoClosureTable(tablePath, newEntityId, parentEntityId, !!subject.metadata.treeLevelColumn);\r\n\r\n        if (subject.metadata.treeLevelColumn) {\r\n            const values = { [subject.metadata.treeLevelColumn.databaseName]: subject.treeLevel };\r\n            await this.queryRunner.update(subject.metadata.tablePath, values, { [referencedColumn.databaseName]: newEntityId });\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Update\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Updates all given subjects in the database.\r\n     */\r\n    private async executeUpdateOperations(): Promise<void> {\r\n        await Promise.all(this.updateSubjects.map(subject => this.update(subject)));\r\n    }\r\n\r\n    /**\r\n     * Updates given subject in the database.\r\n     */\r\n    private async update(subject: Subject): Promise<void> {\r\n        const entity = subject.entity;\r\n\r\n        if (this.connection.driver instanceof MongoDriver) {\r\n            const idMap = subject.metadata.getDatabaseEntityIdMap(entity);\r\n            if (!idMap)\r\n                throw new Error(`Internal error. Cannot get id of the updating entity.`);\r\n\r\n            /*const value: ObjectLiteral = {};\r\n            subject.metadata.columns.forEach(column => {\r\n                const columnValue = column.getEntityValue(entity);\r\n                if (columnValue !== undefined)\r\n                    value[column.databaseName] = columnValue;\r\n            });*/\r\n            // addEmbeddedValuesRecursively(entity, value, subject.metadata.embeddeds);\r\n\r\n            const value: ObjectLiteral = {};\r\n            this.collectColumns(subject.metadata.ownColumns, entity, value, \"update\");\r\n            subject.metadata.embeddeds.forEach(embed => this.collectEmbeds(embed, entity, value, \"update\"));\r\n\r\n            // if number of updated columns = 0 no need to update updated date and version columns\r\n            if (Object.keys(value).length === 0)\r\n                return;\r\n\r\n            if (subject.metadata.updateDateColumn)\r\n                value[subject.metadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);\r\n\r\n            if (subject.metadata.versionColumn)\r\n                value[subject.metadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.versionColumn);\r\n\r\n            return this.queryRunner.update(subject.metadata.tablePath, value, idMap);\r\n        }\r\n\r\n        // we group by table name, because metadata can have different table names\r\n        const valueMaps: { tablePath: string, metadata: EntityMetadata, values: ObjectLiteral }[] = [];\r\n\r\n        // console.log(subject.diffColumns);\r\n        subject.diffColumns.forEach(column => {\r\n            // if (!column.entityTarget) return; // todo: how this can be possible?\r\n            const metadata = this.connection.getMetadata(column.entityMetadata.target);\r\n            let valueMap = valueMaps.find(valueMap => valueMap.tablePath === metadata.tablePath);\r\n            if (!valueMap) {\r\n                valueMap = { tablePath: metadata.tablePath, metadata: metadata, values: {} };\r\n                valueMaps.push(valueMap);\r\n            }\r\n\r\n            valueMap.values[column.databaseName] = this.connection.driver.preparePersistentValue(column.getEntityValue(entity), column);\r\n        });\r\n\r\n        subject.diffRelations.forEach(relation => {\r\n            let valueMap = valueMaps.find(valueMap => valueMap.tablePath === relation.entityMetadata.tablePath);\r\n            if (!valueMap) {\r\n                valueMap = { tablePath: relation.entityMetadata.tablePath, metadata: relation.entityMetadata, values: {} };\r\n                valueMaps.push(valueMap);\r\n            }\r\n\r\n            const value = relation.getEntityValue(entity);\r\n            relation.joinColumns.forEach(joinColumn => {\r\n                valueMap!.values[joinColumn.databaseName] = value !== null && value !== undefined ? value[joinColumn.referencedColumn!.propertyName] : null; // todo: should not have a call to primaryColumn, instead join column metadata should be used\r\n            });\r\n        });\r\n\r\n        // if number of updated columns = 0 no need to update updated date and version columns\r\n        if (Object.keys(valueMaps).length === 0)\r\n            return;\r\n\r\n        if (subject.metadata.updateDateColumn) {\r\n            let valueMap = valueMaps.find(valueMap => valueMap.tablePath === subject.metadata.tablePath);\r\n            if (!valueMap) {\r\n                valueMap = { tablePath: subject.metadata.tablePath, metadata: subject.metadata, values: {} };\r\n                valueMaps.push(valueMap);\r\n            }\r\n\r\n            valueMap.values[subject.metadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.updateDateColumn);\r\n        }\r\n\r\n        if (subject.metadata.versionColumn) {\r\n            let valueMap = valueMaps.find(valueMap => valueMap.tablePath === subject.metadata.tablePath);\r\n            if (!valueMap) {\r\n                valueMap = { tablePath: subject.metadata.tablePath, metadata: subject.metadata, values: {} };\r\n                valueMaps.push(valueMap);\r\n            }\r\n\r\n            valueMap.values[subject.metadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.versionColumn);\r\n        }\r\n\r\n        if (subject.metadata.parentEntityMetadata) {\r\n            if (subject.metadata.parentEntityMetadata.updateDateColumn) {\r\n                let valueMap = valueMaps.find(valueMap => valueMap.tablePath === subject.metadata.parentEntityMetadata.tablePath);\r\n                if (!valueMap) {\r\n                    valueMap = {\r\n                        tablePath: subject.metadata.parentEntityMetadata.tablePath,\r\n                        metadata: subject.metadata.parentEntityMetadata,\r\n                        values: {}\r\n                    };\r\n                    valueMaps.push(valueMap);\r\n                }\r\n\r\n                valueMap.values[subject.metadata.parentEntityMetadata.updateDateColumn.databaseName] = this.connection.driver.preparePersistentValue(new Date(), subject.metadata.parentEntityMetadata.updateDateColumn);\r\n            }\r\n\r\n            if (subject.metadata.parentEntityMetadata.versionColumn) {\r\n                let valueMap = valueMaps.find(valueMap => valueMap.tablePath === subject.metadata.parentEntityMetadata.tablePath);\r\n                if (!valueMap) {\r\n                    valueMap = {\r\n                        tablePath: subject.metadata.parentEntityMetadata.tablePath,\r\n                        metadata: subject.metadata.parentEntityMetadata,\r\n                        values: {}\r\n                    };\r\n                    valueMaps.push(valueMap);\r\n                }\r\n\r\n                valueMap.values[subject.metadata.parentEntityMetadata.versionColumn.databaseName] = this.connection.driver.preparePersistentValue(subject.metadata.parentEntityMetadata.versionColumn.getEntityValue(entity) + 1, subject.metadata.parentEntityMetadata.versionColumn);\r\n            }\r\n        }\r\n\r\n        await Promise.all(valueMaps.map(valueMap => {\r\n            const idMap = valueMap.metadata.getDatabaseEntityIdMap(entity);\r\n            if (!idMap)\r\n                throw new Error(`Internal error. Cannot get id of the updating entity.`);\r\n\r\n            return this.queryRunner.update(valueMap.tablePath, valueMap.values, idMap);\r\n        }));\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Update only relations\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Updates relations of all given subjects in the database.\r\n     */\r\n    private executeUpdateRelations() {\r\n        return Promise.all(this.relationUpdateSubjects.map(subject => this.updateRelations(subject)));\r\n    }\r\n\r\n    /**\r\n     * Updates relations of the given subject in the database.\r\n     */\r\n    private async updateRelations(subject: Subject) {\r\n        const values: ObjectLiteral = {};\r\n        subject.relationUpdates.forEach(setRelation => {\r\n            setRelation.relation.joinColumns.forEach(joinColumn => {\r\n                const value = setRelation.value ? setRelation.value[joinColumn.referencedColumn!.propertyName] : null;\r\n                values[joinColumn.databaseName] = value; // todo: || fromInsertedSubjects ??\r\n            });\r\n        });\r\n\r\n        const idMap = subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity);\r\n        if (!idMap)\r\n            throw new Error(`Internal error. Cannot get id of the updating entity.`);\r\n\r\n        return this.queryRunner.update(subject.metadata.tablePath, values, idMap);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Remove\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Removes all given subjects from the database.\r\n     */\r\n    private async executeRemoveOperations(): Promise<void> {\r\n        await PromiseUtils.runInSequence(this.removeSubjects, async subject => await this.remove(subject));\r\n    }\r\n\r\n    /**\r\n     * Updates given subject from the database.\r\n     */\r\n    private async remove(subject: Subject): Promise<void> {\r\n        if (subject.metadata.parentEntityMetadata) { // this code should not be there. it should be handled by  subject.metadata.getEntityIdColumnMap\r\n            const parentConditions: ObjectLiteral = {};\r\n            subject.metadata.primaryColumns.forEach(column => {\r\n                parentConditions[column.databaseName] = column.getEntityValue(subject.databaseEntity);\r\n            });\r\n            await this.queryRunner.delete(subject.metadata.parentEntityMetadata.tablePath, parentConditions);\r\n\r\n            const childConditions: ObjectLiteral = {};\r\n            subject.metadata.primaryColumns.forEach(column => {\r\n                childConditions[column.databaseName] = column.getEntityValue(subject.databaseEntity);\r\n            });\r\n            await this.queryRunner.delete(subject.metadata.tablePath, childConditions);\r\n        } else {\r\n            await this.queryRunner.delete(subject.metadata.tablePath, subject.metadata.getDatabaseEntityIdMap(subject.databaseEntity)!);\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Insertion into junction tables\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Inserts into database junction tables all given array of subjects junction data.\r\n     */\r\n    private async executeInsertJunctionsOperations(): Promise<void> {\r\n        const promises: Promise<any>[] = [];\r\n        this.allSubjects.forEach(subject => {\r\n            subject.junctionInserts.forEach(junctionInsert => {\r\n                promises.push(this.insertJunctions(subject, junctionInsert));\r\n            });\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * Inserts into database junction table given subject's junction insert data.\r\n     */\r\n    private async insertJunctions(subject: Subject, junctionInsert: JunctionInsert): Promise<void> {\r\n        // I think here we can only support to work only with single primary key entities\r\n\r\n        const getRelationId = (entity: ObjectLiteral, joinColumns: ColumnMetadata[]): any[] => {\r\n            return joinColumns.map(joinColumn => {\r\n                const id = joinColumn.referencedColumn!.getEntityValue(entity);\r\n                if (!id && joinColumn.referencedColumn!.isGenerated) {\r\n                    const insertSubject = this.insertSubjects.find(subject => subject.entity === entity);\r\n                    if (insertSubject && insertSubject.generatedMap)\r\n                        return joinColumn.referencedColumn!.getEntityValue(insertSubject.generatedMap);\r\n                }\r\n                // todo: implement other special referenced column types (update date, create date, version, discriminator column, etc.)\r\n\r\n                return id;\r\n            });\r\n        };\r\n\r\n        const relation = junctionInsert.relation;\r\n        const joinColumns = relation.isManyToManyOwner ? relation.joinColumns : relation.inverseRelation!.inverseJoinColumns;\r\n        const ownId = getRelationId(subject.entity, joinColumns);\r\n\r\n        if (!ownId.length)\r\n            throw new Error(`Cannot insert object of ${subject.entityTarget} type. Looks like its not persisted yet, or cascades are not set on the relation.`); // todo: better error message\r\n\r\n        const promises = junctionInsert.junctionEntities.map(newBindEntity => {\r\n\r\n            // get relation id from the newly bind entity\r\n            const joinColumns = relation.isManyToManyOwner ? relation.inverseJoinColumns : relation.inverseRelation!.joinColumns;\r\n            const relationId = getRelationId(newBindEntity, joinColumns);\r\n\r\n            // if relation id still does not exist - we arise an error\r\n            if (!relationId)\r\n                throw new Error(`Cannot insert object of ${(newBindEntity.constructor as any).name} type. Looks like its not persisted yet, or cascades are not set on the relation.`); // todo: better error message\r\n\r\n            const columns = relation.junctionEntityMetadata!.columns.map(column => column.databaseName);\r\n            const values = relation.isOwning ? [...ownId, ...relationId] : [...relationId, ...ownId];\r\n\r\n            return this.queryRunner.insert(relation.junctionEntityMetadata!.tablePath, OrmUtils.zipObject(columns, values));\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Remove from junction tables\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Removes from database junction tables all given array of subjects removal junction data.\r\n     */\r\n    private async executeRemoveJunctionsOperations(): Promise<void> {\r\n        const promises: Promise<any>[] = [];\r\n        this.allSubjects.forEach(subject => {\r\n            subject.junctionRemoves.forEach(junctionRemove => {\r\n                promises.push(this.removeJunctions(subject, junctionRemove));\r\n            });\r\n        });\r\n\r\n        await Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * Removes from database junction table all given subject's removal junction data.\r\n     */\r\n    private async removeJunctions(subject: Subject, junctionRemove: JunctionRemove) {\r\n        const junctionMetadata = junctionRemove.relation.junctionEntityMetadata!;\r\n        const entity = subject.hasEntity ? subject.entity : subject.databaseEntity;\r\n\r\n        const firstJoinColumns = junctionRemove.relation.isOwning ? junctionRemove.relation.joinColumns : junctionRemove.relation.inverseRelation!.inverseJoinColumns;\r\n        const secondJoinColumns = junctionRemove.relation.isOwning ? junctionRemove.relation.inverseJoinColumns : junctionRemove.relation.inverseRelation!.joinColumns;\r\n        let conditions: ObjectLiteral = {};\r\n        firstJoinColumns.forEach(joinColumn => {\r\n            conditions[joinColumn.databaseName] = joinColumn.referencedColumn!.getEntityValue(entity);\r\n        });\r\n\r\n        const removePromises = junctionRemove.junctionRelationIds.map(relationIds => {\r\n            let inverseConditions: ObjectLiteral = {};\r\n            secondJoinColumns.forEach(joinColumn => {\r\n                inverseConditions[joinColumn.databaseName] = joinColumn.referencedColumn!.getEntityValue(relationIds);\r\n            });\r\n            return this.queryRunner.delete(junctionMetadata.tableName, Object.assign({}, inverseConditions, conditions));\r\n        });\r\n\r\n        await Promise.all(removePromises);\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Private Methods: Refresh entity values after persistence\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Updates all special columns of the saving entities (create date, update date, versioning).\r\n     */\r\n    private updateSpecialColumnsInPersistedEntities() {\r\n\r\n        // update entity columns that gets updated on each entity insert\r\n        this.insertSubjects.forEach(subject => {\r\n            // if (subject.generatedObjectId && subject.metadata.objectIdColumn)\r\n            //     subject.metadata.objectIdColumn.setEntityValue(subject.entity, subject.generatedObjectId);\r\n\r\n            if (subject.generatedMap) {\r\n                subject.metadata.generatedColumns.forEach(generatedColumn => {\r\n                    const generatedValue = generatedColumn.getEntityValue(subject.generatedMap!);\r\n                    if (!generatedValue)\r\n                        return;\r\n\r\n                    generatedColumn.setEntityValue(subject.entity, generatedValue);\r\n                });\r\n            }\r\n            subject.metadata.primaryColumns.forEach(primaryColumn => {\r\n                if (subject.parentGeneratedId)\r\n                    primaryColumn.setEntityValue(subject.entity, subject.parentGeneratedId);\r\n            });\r\n\r\n            if (subject.metadata.updateDateColumn)\r\n                subject.metadata.updateDateColumn.setEntityValue(subject.entity, subject.date);\r\n            if (subject.metadata.createDateColumn)\r\n                subject.metadata.createDateColumn.setEntityValue(subject.entity, subject.date);\r\n            if (subject.metadata.versionColumn)\r\n                subject.metadata.versionColumn.setEntityValue(subject.entity, 1);\r\n            if (subject.metadata.treeLevelColumn) {\r\n                // const parentEntity = insertOperation.entity[metadata.treeParentMetadata.propertyName];\r\n                // const parentLevel = parentEntity ? (parentEntity[metadata.treeLevelColumn.propertyName] || 0) : 0;\r\n                subject.metadata.treeLevelColumn.setEntityValue(subject.entity, subject.treeLevel);\r\n            }\r\n            /*if (subject.metadata.hasTreeChildrenCountColumn) {\r\n                 subject.entity[subject.metadata.treeChildrenCountColumn.propertyName] = 0;\r\n            }*/\r\n\r\n            // set values to \"null\" for nullable columns that did not have values\r\n            subject.metadata.columns\r\n                .filter(column => column.isNullable && !column.isVirtual)\r\n                .forEach(column => {\r\n                    const columnValue = column.getEntityValue(subject.entity);\r\n                    if (columnValue === undefined)\r\n                        column.setEntityValue(subject.entity, null);\r\n                });\r\n        });\r\n\r\n        // update special columns that gets updated on each entity update\r\n        this.updateSubjects.forEach(subject => {\r\n            if (subject.metadata.updateDateColumn)\r\n                subject.metadata.updateDateColumn.setEntityValue(subject.entity, subject.date);\r\n            if (subject.metadata.versionColumn)\r\n                subject.metadata.versionColumn.setEntityValue(subject.entity, subject.metadata.versionColumn.getEntityValue(subject.entity) + 1);\r\n        });\r\n\r\n        // remove ids from the entities that were removed\r\n        this.removeSubjects\r\n            .filter(subject => subject.hasEntity)\r\n            .forEach(subject => {\r\n                subject.metadata.primaryColumns.forEach(primaryColumn => {\r\n                    primaryColumn.setEntityValue(subject.entity, undefined);\r\n                });\r\n            });\r\n\r\n        this.allSubjects\r\n            .filter(subject => subject.hasEntity)\r\n            .forEach(subject => {\r\n                subject.metadata.relationIds.forEach(relationId => {\r\n                    relationId.setValue(subject.entity);\r\n                });\r\n            });\r\n    }\r\n\r\n}\r\n"],"sourceRoot":".."}