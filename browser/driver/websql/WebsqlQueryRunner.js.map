{"version":3,"sources":["../browser/src/driver/websql/WebsqlQueryRunner.ts"],"names":[],"mappings":"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","file":"WebsqlQueryRunner.js","sourcesContent":["import {ObjectLiteral} from \"../../common/ObjectLiteral\";\r\nimport {TransactionAlreadyStartedError} from \"../../error/TransactionAlreadyStartedError\";\r\nimport {TransactionNotStartedError} from \"../../error/TransactionNotStartedError\";\r\nimport {Table} from \"../../schema-builder/schema/Table\";\r\nimport {QueryRunnerAlreadyReleasedError} from \"../../error/QueryRunnerAlreadyReleasedError\";\r\nimport {OrmUtils} from \"../../util/OrmUtils\";\r\nimport {InsertResult} from \"../InsertResult\";\r\nimport {QueryFailedError} from \"../../error/QueryFailedError\";\r\nimport {AbstractSqliteQueryRunner} from \"../sqlite-abstract/AbstractSqliteQueryRunner\";\r\nimport {WebsqlDriver} from \"./WebsqlDriver\";\r\n\r\n/**\r\n * Declare a global function that is only available in browsers that support WebSQL.\r\n */\r\ndeclare function openDatabase(...params: any[]): any;\r\n\r\n/**\r\n * Runs queries on a single websql database connection.\r\n */\r\nexport class WebsqlQueryRunner extends AbstractSqliteQueryRunner {\r\n    /**\r\n     * Real database connection from a connection pool used to perform queries.\r\n     */\r\n    protected databaseConnection: any;\r\n\r\n    /**\r\n     * Promise used to obtain a database connection for a first time.\r\n     */\r\n    protected databaseConnectionPromise: Promise<any>;\r\n\r\n    /**\r\n     * Database driver used by connection.\r\n     */\r\n    driver: WebsqlDriver;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(driver: WebsqlDriver) {\r\n        super(driver);\r\n\r\n        this.driver = driver;\r\n        this.connection = driver.connection;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates/uses database connection from the connection pool to perform further operations.\r\n     * Returns obtained database connection.\r\n     */\r\n    connect(): Promise<any> {\r\n        if (this.databaseConnection)\r\n            return Promise.resolve(this.databaseConnection);\r\n\r\n        if (this.databaseConnectionPromise)\r\n            return this.databaseConnectionPromise;\r\n\r\n        const options = Object.assign({}, {\r\n            database: this.driver.options.database,\r\n            version: this.driver.options.version,\r\n            description: this.driver.options.description,\r\n            size: this.driver.options.size,\r\n        }, this.driver.options.extra || {});\r\n\r\n        this.databaseConnectionPromise = new Promise<void>((ok, fail) => {\r\n            this.databaseConnection = openDatabase(\r\n                options.database,\r\n                options.version,\r\n                options.description,\r\n                options.size,\r\n            );\r\n            ok(this.databaseConnection);\r\n        });\r\n\r\n        return this.databaseConnectionPromise;\r\n    }\r\n\r\n    /**\r\n     * Starts transaction.\r\n     */\r\n    async startTransaction(): Promise<void> {\r\n        if (this.isReleased)\r\n            throw new QueryRunnerAlreadyReleasedError();\r\n\r\n        if (this.isTransactionActive)\r\n            throw new TransactionAlreadyStartedError();\r\n\r\n        this.isTransactionActive = true;\r\n        // await this.query(\"BEGIN TRANSACTION\");\r\n    }\r\n\r\n    /**\r\n     * Commits transaction.\r\n     * Error will be thrown if transaction was not started.\r\n     */\r\n    async commitTransaction(): Promise<void> {\r\n        if (this.isReleased)\r\n            throw new QueryRunnerAlreadyReleasedError();\r\n\r\n        if (!this.isTransactionActive)\r\n            throw new TransactionNotStartedError();\r\n\r\n        // await this.query(\"COMMIT\");\r\n        this.isTransactionActive = false;\r\n    }\r\n\r\n    /**\r\n     * Rollbacks transaction.\r\n     * Error will be thrown if transaction was not started.\r\n     */\r\n    async rollbackTransaction(): Promise<void> {\r\n        if (this.isReleased)\r\n            throw new QueryRunnerAlreadyReleasedError();\r\n\r\n        if (!this.isTransactionActive)\r\n            throw new TransactionNotStartedError();\r\n\r\n        // await this.query(\"ROLLBACK\");\r\n        this.isTransactionActive = false;\r\n    }\r\n\r\n    /**\r\n     * Executes a given SQL query.\r\n     */\r\n    query(query: string, parameters?: any[]): Promise<any> {\r\n        if (this.isReleased)\r\n            throw new QueryRunnerAlreadyReleasedError();\r\n\r\n        return new Promise(async (ok, fail) => {\r\n            try {\r\n                const db = await this.connect();\r\n                // todo(dima): check if transaction is not active\r\n\r\n                this.driver.connection.logger.logQuery(query, parameters, this);\r\n                const queryStartTime = +new Date();\r\n\r\n                db.transaction((tx: any) => {\r\n                    tx.executeSql(query, parameters, (tx: any, result: any) => {\r\n\r\n                        // log slow queries if maxQueryExecution time is set\r\n                        const maxQueryExecutionTime = this.driver.connection.options.maxQueryExecutionTime;\r\n                        const queryEndTime = +new Date();\r\n                        const queryExecutionTime = queryEndTime - queryStartTime;\r\n                        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime)\r\n                            this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\r\n\r\n                        const rows = Object\r\n                            .keys(result.rows)\r\n                            .filter(key => key !== \"length\")\r\n                            .map(key => result.rows[key]);\r\n                        ok(rows);\r\n\r\n                    }, (tx: any, err: any) => {\r\n                        this.driver.connection.logger.logQueryError(err, query, parameters, this);\r\n                        return fail(new QueryFailedError(query, parameters, err));\r\n                    });\r\n                });\r\n\r\n            } catch (err) {\r\n                fail(err);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Insert a new row with given values into the given table.\r\n     * Returns value of the generated column if given and generate column exist in the table.\r\n     */\r\n    async insert(tableName: string, keyValues: ObjectLiteral): Promise<InsertResult> {\r\n        const keys = Object.keys(keyValues);\r\n        const columns = keys.map(key => `\"${key}\"`).join(\", \");\r\n        const values = keys.map((key, index) => \"$\" + (index + 1)).join(\",\");\r\n        const generatedColumns = this.connection.hasMetadata(tableName) ? this.connection.getMetadata(tableName).generatedColumns : [];\r\n        const sql = columns.length > 0 ? (`INSERT INTO \"${tableName}\"(${columns}) VALUES (${values})`) : `INSERT INTO \"${tableName}\" DEFAULT VALUES`;\r\n        const parameters = keys.map(key => keyValues[key]);\r\n\r\n        return new Promise<InsertResult>(async (ok, fail) => {\r\n            this.driver.connection.logger.logQuery(sql, parameters, this);\r\n\r\n            const db = await this.connect();\r\n            // todo: check if transaction is not active\r\n            db.transaction((tx: any) => {\r\n                tx.executeSql(sql, parameters, (tx: any, result: any) => {\r\n                    const generatedMap = generatedColumns.reduce((map, generatedColumn) => {\r\n                        const value = generatedColumn.isPrimary && generatedColumn.generationStrategy === \"increment\" && result[\"insertId\"] ? result[\"insertId\"] : keyValues[generatedColumn.databaseName];\r\n                        if (!value) return map;\r\n                        return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\r\n                    }, {} as ObjectLiteral);\r\n\r\n                    ok({\r\n                        result: undefined,\r\n                        generatedMap: Object.keys(generatedMap).length > 0 ? generatedMap : undefined\r\n                    });\r\n\r\n                }, (tx: any, err: any) => {\r\n                    this.driver.connection.logger.logQueryError(err, sql, parameters, this);\r\n                    return fail(err);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    // TODO: finish the table schema loading\r\n    /**\r\n     * Loads all tables (with given names) from the database and creates a Table from them.\r\n     */\r\n    async getTables(tableNames: string[]): Promise<Table[]> {\r\n\r\n        // if no tables given then no need to proceed\r\n        if (!tableNames || !tableNames.length)\r\n            return [];\r\n\r\n        const tableNamesString = tableNames.map(tableName => `'${tableName}'`).join(\", \");\r\n\r\n        // load tables, columns, indices and foreign keys\r\n        const dbTables: ObjectLiteral[] = await this.query(`SELECT * FROM sqlite_master WHERE type = 'table' AND name IN (${tableNamesString})`);\r\n\r\n        // if tables were not found in the db, no need to proceed\r\n        if (!dbTables || !dbTables.length)\r\n            return [];\r\n\r\n        // create table schemas for loaded tables\r\n        return Promise.all(dbTables.map(async dbTable => {\r\n            const table = new Table(dbTable[\"name\"]);\r\n\r\n            // load columns and indices\r\n            /*const [dbColumns, dbIndices, dbForeignKeys]: ObjectLiteral[][] = await Promise.all([\r\n                this.query(`PRAGMA table_info(\"${dbTable[\"name\"]}\")`),\r\n                this.query(`PRAGMA index_list(\"${dbTable[\"name\"]}\")`),\r\n                this.query(`PRAGMA foreign_key_list(\"${dbTable[\"name\"]}\")`),\r\n            ]);\r\n\r\n            // find column name with auto increment\r\n            let autoIncrementColumnName: string|undefined = undefined;\r\n            const tableSql: string = dbTable[\"sql\"];\r\n            if (tableSql.indexOf(\"AUTOINCREMENT\") !== -1) {\r\n                autoIncrementColumnName = tableSql.substr(0, tableSql.indexOf(\"AUTOINCREMENT\"));\r\n                const comma = autoIncrementColumnName.lastIndexOf(\",\");\r\n                const bracket = autoIncrementColumnName.lastIndexOf(\"(\");\r\n                if (comma !== -1) {\r\n                    autoIncrementColumnName = autoIncrementColumnName.substr(comma);\r\n                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\r\n                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\r\n\r\n                } else if (bracket !== -1) {\r\n                    autoIncrementColumnName = autoIncrementColumnName.substr(bracket);\r\n                    autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf(\"\\\"\"));\r\n                    autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf(\"\\\"\") + 1);\r\n                }\r\n            }\r\n\r\n            // create columns from the loaded columns\r\n            table.columns = dbColumns.map(dbColumn => {\r\n                const tableColumn = new TableColumn();\r\n                tableColumn.name = dbColumn[\"name\"];\r\n                tableColumn.type = dbColumn[\"type\"].toLowerCase();\r\n                tableColumn.default = dbColumn[\"dflt_value\"] !== null && dbColumn[\"dflt_value\"] !== undefined ? dbColumn[\"dflt_value\"] : undefined;\r\n                tableColumn.isNullable = dbColumn[\"notnull\"] === 0;\r\n                tableColumn.isPrimary = dbColumn[\"pk\"] === 1;\r\n                tableColumn.comment = \"\"; // todo later\r\n                tableColumn.isGenerated = autoIncrementColumnName === dbColumn[\"name\"];\r\n                const columnForeignKeys = dbForeignKeys\r\n                    .filter(foreignKey => foreignKey[\"from\"] === dbColumn[\"name\"])\r\n                    .map(foreignKey => {\r\n                        const keyName = namingStrategy.foreignKeyName(dbTable[\"name\"], [foreignKey[\"from\"]], foreignKey[\"table\"], [foreignKey[\"to\"]]);\r\n                        return new TableForeignKey(keyName, [foreignKey[\"from\"]], [foreignKey[\"to\"]], foreignKey[\"table\"], foreignKey[\"on_delete\"]); // todo: how sqlite return from and to when they are arrays? (multiple column foreign keys)\r\n                    });\r\n                table.addForeignKeys(columnForeignKeys);\r\n                return tableColumn;\r\n            });\r\n\r\n            // create primary key schema\r\n            await Promise.all(dbIndices\r\n                .filter(index => index[\"origin\"] === \"pk\")\r\n                .map(async index => {\r\n                    const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info(\"${index[\"name\"]}\")`);\r\n                    const indexColumns = indexInfos.map(indexInfo => indexInfo[\"name\"]);\r\n                    indexColumns.forEach(indexColumn => {\r\n                        table.primaryKeys.push(new TablePrimaryKey(index[\"name\"], indexColumn));\r\n                    });\r\n                }));\r\n\r\n            // create index schemas from the loaded indices\r\n            const indicesPromises = dbIndices\r\n                .filter(dbIndex => {\r\n                    return  dbIndex[\"origin\"] !== \"pk\" &&\r\n                        (!table.foreignKeys.find(foreignKey => foreignKey.name === dbIndex[\"name\"])) &&\r\n                        (!table.primaryKeys.find(primaryKey => primaryKey.name === dbIndex[\"name\"]));\r\n                })\r\n                .map(dbIndex => dbIndex[\"name\"])\r\n                .filter((value, index, self) => self.indexOf(value) === index) // unqiue\r\n                .map(async dbIndexName => {\r\n                    const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\r\n                    const indexInfos: ObjectLiteral[] = await this.query(`PRAGMA index_info(\"${dbIndex![\"name\"]}\")`);\r\n                    const indexColumns = indexInfos.map(indexInfo => indexInfo[\"name\"]);\r\n\r\n                    // check if db index is generated by sqlite itself and has special use case\r\n                    if (dbIndex![\"name\"].substr(0, \"sqlite_autoindex\".length) === \"sqlite_autoindex\") {\r\n                        if (dbIndex![\"unique\"] === 1) { // this means we have a special index generated for a column\r\n                            // so we find and update the column\r\n                            indexColumns.forEach(columnName => {\r\n                                const column = table.columns.find(column => column.name === columnName);\r\n                                if (column)\r\n                                    column.isUnique = true;\r\n                            });\r\n                        }\r\n\r\n                        return Promise.resolve(undefined);\r\n\r\n                    } else {\r\n                        return new TableIndex(dbTable[\"name\"], dbIndex![\"name\"], indexColumns, dbIndex![\"unique\"] === \"1\");\r\n                    }\r\n                });\r\n\r\n            const indices = await Promise.all(indicesPromises);\r\n            table.indices = indices.filter(index => !!index) as TableIndex[];*/\r\n\r\n            return table;\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Removes all tables from the currently connected database.\r\n     */\r\n    async clearDatabase(): Promise<void> {\r\n        // await this.query(`PRAGMA foreign_keys = OFF;`);\r\n        await this.startTransaction();\r\n        try {\r\n            const selectDropsQuery = `select 'drop table \"' || name || '\";' as query from sqlite_master where type = 'table' and name != 'sqlite_sequence'`;\r\n            const dropQueries: ObjectLiteral[] = await this.query(selectDropsQuery);\r\n            await Promise.all(dropQueries.map(q => this.query(q[\"query\"])));\r\n            await this.commitTransaction();\r\n\r\n        } catch (error) {\r\n            try { // we throw original error even if rollback thrown an error\r\n                await this.rollbackTransaction();\r\n            } catch (rollbackError) { }\r\n            throw error;\r\n\r\n            // await this.query(`PRAGMA foreign_keys = ON;`);\r\n        }\r\n    }\r\n}"],"sourceRoot":"../.."}