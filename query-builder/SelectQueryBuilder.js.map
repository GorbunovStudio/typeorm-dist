{"version":3,"sources":["../../src/query-builder/SelectQueryBuilder.ts"],"names":[],"mappings":"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","file":"SelectQueryBuilder.js","sourcesContent":["import {RawSqlResultsToEntityTransformer} from \"./transformer/RawSqlResultsToEntityTransformer\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\r\nimport {PessimisticLockTransactionRequiredError} from \"../error/PessimisticLockTransactionRequiredError\";\r\nimport {NoVersionOrUpdateDateColumnError} from \"../error/NoVersionOrUpdateDateColumnError\";\r\nimport {OptimisticLockVersionMismatchError} from \"../error/OptimisticLockVersionMismatchError\";\r\nimport {OptimisticLockCanNotBeUsedError} from \"../error/OptimisticLockCanNotBeUsedError\";\r\nimport {JoinAttribute} from \"./JoinAttribute\";\r\nimport {RelationIdAttribute} from \"./relation-id/RelationIdAttribute\";\r\nimport {RelationCountAttribute} from \"./relation-count/RelationCountAttribute\";\r\nimport {RelationIdLoader} from \"./relation-id/RelationIdLoader\";\r\nimport {RelationIdMetadataToAttributeTransformer} from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\r\nimport {RelationCountLoader} from \"./relation-count/RelationCountLoader\";\r\nimport {RelationCountMetadataToAttributeTransformer} from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\r\nimport {Broadcaster} from \"../subscriber/Broadcaster\";\r\nimport {QueryBuilder} from \"./QueryBuilder\";\r\nimport {ReadStream} from \"../platform/PlatformTools\";\r\nimport {LockNotSupportedOnGivenDriverError} from \"../error/LockNotSupportedOnGivenDriverError\";\r\nimport {MysqlDriver} from \"../driver/mysql/MysqlDriver\";\r\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\r\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\r\nimport {SelectQuery} from \"./SelectQuery\";\r\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\r\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\r\nimport {ObjectType} from \"../common/ObjectType\";\r\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\r\nimport {WhereExpression} from \"./WhereExpression\";\r\nimport {Brackets} from \"./Brackets\";\r\nimport {AbstractSqliteDriver} from \"../driver/sqlite-abstract/AbstractSqliteDriver\";\r\nimport {QueryResultCacheOptions} from \"../cache/QueryResultCacheOptions\";\r\nimport {OffsetWithoutLimitNotSupportedError} from \"../error/OffsetWithoutLimitNotSupportedError\";\r\n\r\n/**\r\n * Allows to build complex sql queries in a fashion way and execute those queries.\r\n */\r\nexport class SelectQueryBuilder<Entity> extends QueryBuilder<Entity> implements WhereExpression {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Implemented Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets generated sql query without parameters being replaced.\r\n     */\r\n    getQuery(): string {\r\n        let sql = this.createSelectExpression();\r\n        sql += this.createJoinExpression();\r\n        sql += this.createWhereExpression();\r\n        sql += this.createGroupByExpression();\r\n        sql += this.createHavingExpression();\r\n        sql += this.createOrderByExpression();\r\n        sql += this.createLimitOffsetExpression();\r\n        sql += this.createLockExpression();\r\n        sql = this.createLimitOffsetOracleSpecificExpression(sql);\r\n        sql = sql.trim();\r\n        if (this.expressionMap.subQuery)\r\n            sql = \"(\" + sql + \")\";\r\n        return sql;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a subquery - query that can be used inside other queries.\r\n     */\r\n    subQuery(): SelectQueryBuilder<any> {\r\n        const qb = this.createQueryBuilder();\r\n        qb.expressionMap.subQuery = true;\r\n        qb.expressionMap.parentQueryBuilder = this;\r\n        return qb;\r\n    }\r\n\r\n    /**\r\n     * Creates SELECT query.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(): this;\r\n\r\n    /**\r\n     * Creates SELECT query.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, selectionAliasName?: string): this;\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: string, selectionAliasName?: string): this;\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: string[]): this;\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection?: string|string[]|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), selectionAliasName?: string): SelectQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"select\";\r\n        if (selection instanceof Array) {\r\n            this.expressionMap.selects = selection.map(selection => ({ selection: selection }));\r\n\r\n        } else if (selection instanceof Function) {\r\n            const subQueryBuilder = selection(this.subQuery());\r\n            this.setParameters(subQueryBuilder.getParameters());\r\n            this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });\r\n\r\n        } else if (selection) {\r\n            this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(selection: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, selectionAliasName?: string): this;\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(selection: string, selectionAliasName?: string): this;\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(selection: string[]): this;\r\n\r\n    /**\r\n     * Adds new selection to the SELECT query.\r\n     */\r\n    addSelect(selection: string|string[]|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), selectionAliasName?: string): this {\r\n        if (!selection)\r\n            return this;\r\n\r\n        if (selection instanceof Array) {\r\n            this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(selection => ({ selection: selection })));\r\n\r\n        } else if (selection instanceof Function) {\r\n            const subQueryBuilder = selection(this.subQuery());\r\n            this.setParameters(subQueryBuilder.getParameters());\r\n            this.expressionMap.selects.push({ selection: subQueryBuilder.getQuery(), aliasName: selectionAliasName });\r\n\r\n        } else if (selection) {\r\n            this.expressionMap.selects.push({ selection: selection, aliasName: selectionAliasName });\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     * Removes all previously set from-s.\r\n     */\r\n    from<T>(entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string): SelectQueryBuilder<T>;\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     * Removes all previously set from-s.\r\n     */\r\n    from<T>(entityTarget: ObjectType<T>|string, aliasName: string): SelectQueryBuilder<T>;\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     * Removes all previously set from-s.\r\n     */\r\n    from<T>(entityTarget: ObjectType<T>|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string): SelectQueryBuilder<T> {\r\n        const mainAlias = this.createFromAlias(entityTarget, aliasName);\r\n        this.expressionMap.setMainAlias(mainAlias);\r\n        return (this as any) as SelectQueryBuilder<T>;\r\n    }\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    addFrom<T>(entityTarget: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string): SelectQueryBuilder<T>;\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    addFrom<T>(entityTarget: ObjectType<T>|string, aliasName: string): SelectQueryBuilder<T>;\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    addFrom<T>(entityTarget: ObjectType<T>|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string): SelectQueryBuilder<T> {\r\n        const alias = this.createFromAlias(entityTarget, aliasName);\r\n        if (!this.expressionMap.mainAlias)\r\n            this.expressionMap.setMainAlias(alias);\r\n\r\n        return (this as any) as SelectQueryBuilder<T>;\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs (without selection) given subquery.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs (without selection) entity's property.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs (without selection) given entity's table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(entity: Function|string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs (without selection) given table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(tableName: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs (without selection).\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoin(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.join(\"INNER\", entityOrProperty, aliasName, condition, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) given subquery.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) entity's property.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) entity's table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(entity: Function|string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs (without selection) given table.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(tableName: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs (without selection).\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoin(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.join(\"LEFT\", entityOrProperty, aliasName, condition, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs given subquery and adds all selection properties to SELECT..\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs entity's property and adds all selection properties to SELECT.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs entity and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(entity: Function|string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs table and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(tableName: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndSelect(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.addSelect(aliasName);\r\n        this.innerJoin(entityOrProperty, aliasName, condition, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs given subquery and adds all selection properties to SELECT..\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs entity's property and adds all selection properties to SELECT.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs entity and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(entity: Function|string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs table and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(tableName: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs and adds all selection properties to SELECT.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndSelect(entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.addSelect(aliasName);\r\n        this.leftJoin(entityOrProperty, aliasName, condition, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(mapToProperty: string, property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(mapToProperty: string, tableName: string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.addSelect(aliasName);\r\n        this.join(\"INNER\", entityOrProperty, aliasName, condition, parameters, mapToProperty, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * INNER JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(mapToProperty: string, property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(mapToProperty: string, tableName: string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    innerJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.addSelect(aliasName);\r\n        this.join(\"INNER\", entityOrProperty, aliasName, condition, parameters, mapToProperty, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(mapToProperty: string, property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(mapToProperty: string, tableName: string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapMany(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.addSelect(aliasName);\r\n        this.join(\"LEFT\", entityOrProperty, aliasName, condition, parameters, mapToProperty, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * LEFT JOINs given subquery, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(mapToProperty: string, subQueryFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs entity's property, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * Given entity property should be a relation.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(mapToProperty: string, property: string, aliasName: string, condition?: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs entity's table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(mapToProperty: string, entity: Function|string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs table, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(mapToProperty: string, tableName: string, aliasName: string, condition: string, parameters?: ObjectLiteral): this;\r\n\r\n    /**\r\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\r\n     * This is extremely useful when you want to select some data and map it to some virtual property.\r\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\r\n     * You also need to specify an alias of the joined data.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    leftJoinAndMapOne(mapToProperty: string, entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName: string, condition: string = \"\", parameters?: ObjectLiteral): this {\r\n        this.addSelect(aliasName);\r\n        this.join(\"LEFT\", entityOrProperty, aliasName, condition, parameters, mapToProperty, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, property: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, entity: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, tableName: string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this;\r\n\r\n    /**\r\n     */\r\n    // selectAndMap(mapToProperty: string, entityOrProperty: Function|string, aliasName: string, qbFactory: ((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>)): this {\r\n    //     const select = new SelectAttribute(this.expressionMap);\r\n    //     select.mapToProperty = mapToProperty;\r\n    //     select.entityOrProperty = entityOrProperty;\r\n    //     select.aliasName = aliasName;\r\n    //     select.qbFactory = qbFactory;\r\n    //     return this;\r\n    // }\r\n\r\n    /**\r\n     * LEFT JOINs relation id and maps it into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationIdAndMap(mapToProperty: string, relationName: string): this;\r\n\r\n    /**\r\n     * LEFT JOINs relation id and maps it into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, options: { disableMixedMap: boolean }): this;\r\n\r\n    /**\r\n     * LEFT JOINs relation id and maps it into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationIdAndMap(mapToProperty: string, relationName: string, aliasName: string, queryBuilderFactory: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this;\r\n\r\n    /**\r\n     * LEFT JOINs relation id and maps it into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationIdAndMap(mapToProperty: string,\r\n                         relationName: string,\r\n                         aliasNameOrOptions?: string|{ disableMixedMap?: boolean },\r\n                         queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\r\n\r\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\r\n        relationIdAttribute.mapToProperty = mapToProperty;\r\n        relationIdAttribute.relationName = relationName;\r\n        if (typeof aliasNameOrOptions === \"string\")\r\n            relationIdAttribute.alias = aliasNameOrOptions;\r\n        if (aliasNameOrOptions instanceof Object && (aliasNameOrOptions as any).disableMixedMap)\r\n            relationIdAttribute.disableMixedMap = true;\r\n\r\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\r\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute);\r\n\r\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\r\n            this.expressionMap.createAlias({\r\n                type: \"other\",\r\n                name: relationIdAttribute.junctionAlias,\r\n                metadata: relationIdAttribute.relation.junctionEntityMetadata\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\r\n     * Optionally, you can add condition and parameters used in condition.\r\n     */\r\n    loadRelationCountAndMap(mapToProperty: string, relationName: string, aliasName?: string, queryBuilderFactory?: (qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>): this {\r\n        const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\r\n        relationCountAttribute.mapToProperty = mapToProperty;\r\n        relationCountAttribute.relationName = relationName;\r\n        relationCountAttribute.alias = aliasName;\r\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\r\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute);\r\n\r\n        this.expressionMap.createAlias({\r\n            type: \"other\",\r\n            name: relationCountAttribute.junctionAlias\r\n        });\r\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\r\n            this.expressionMap.createAlias({\r\n                type: \"other\",\r\n                name: relationCountAttribute.junctionAlias,\r\n                metadata: relationCountAttribute.relation.junctionEntityMetadata\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Loads all relation ids for all relations of the selected entity.\r\n     * All relation ids will be mapped to relation property themself.\r\n     */\r\n    loadAllRelationIds(): this {\r\n        this.expressionMap.mainAlias!.metadata.relations.forEach(relation => {\r\n            this.loadRelationIdAndMap(\r\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\r\n                this.expressionMap.mainAlias!.name + \".\" + relation.propertyPath,\r\n                { disableMixedMap: true }\r\n            );\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets WHERE condition in the query builder.\r\n     * If you had previously WHERE expression defined,\r\n     * calling this function will override previously set WHERE conditions.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    where(where: Brackets|string|((qb: this) => string)|ObjectLiteral, parameters?: ObjectLiteral): this {\r\n        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\r\n        const condition = this.computeWhereParameter(where);\r\n        if (condition)\r\n            this.expressionMap.wheres = [{ type: \"simple\", condition: condition }];\r\n        if (parameters)\r\n            this.setParameters(parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new AND WHERE condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    andWhere(where: string|Brackets|((qb: this) => string), parameters?: ObjectLiteral): this {\r\n        this.expressionMap.wheres.push({ type: \"and\", condition: this.computeWhereParameter(where) });\r\n        if (parameters) this.setParameters(parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new OR WHERE condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    orWhere(where: Brackets|string|((qb: this) => string), parameters?: ObjectLiteral): this {\r\n        this.expressionMap.wheres.push({ type: \"or\", condition: this.computeWhereParameter(where) });\r\n        if (parameters) this.setParameters(parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new AND WHERE with conditions for the given ids.\r\n     *\r\n     * Ids are mixed.\r\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\r\n     * If you have multiple primary keys you need to pass object with property names and values specified,\r\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\r\n     */\r\n    whereInIds(ids: any|any[]): this {\r\n        ids = ids instanceof Array ? ids : [ids];\r\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\r\n        this.where(whereExpression, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new AND WHERE with conditions for the given ids.\r\n     *\r\n     * Ids are mixed.\r\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\r\n     * If you have multiple primary keys you need to pass object with property names and values specified,\r\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\r\n     */\r\n    andWhereInIds(ids: any[]): this {\r\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\r\n        this.andWhere(whereExpression, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new OR WHERE with conditions for the given ids.\r\n     *\r\n     * Ids are mixed.\r\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\r\n     * If you have multiple primary keys you need to pass object with property names and values specified,\r\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\r\n     */\r\n    orWhereInIds(ids: any[]): this {\r\n        const [whereExpression, parameters] = this.createWhereIdsExpression(ids);\r\n        this.orWhere(whereExpression, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets HAVING condition in the query builder.\r\n     * If you had previously HAVING expression defined,\r\n     * calling this function will override previously set HAVING conditions.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    having(having: string, parameters?: ObjectLiteral): this {\r\n        this.expressionMap.havings.push({ type: \"simple\", condition: having });\r\n        if (parameters) this.setParameters(parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new AND HAVING condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    andHaving(having: string, parameters?: ObjectLiteral): this {\r\n        this.expressionMap.havings.push({ type: \"and\", condition: having });\r\n        if (parameters) this.setParameters(parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds new OR HAVING condition in the query builder.\r\n     * Additionally you can add parameters used in where expression.\r\n     */\r\n    orHaving(having: string, parameters?: ObjectLiteral): this {\r\n        this.expressionMap.havings.push({ type: \"or\", condition: having });\r\n        if (parameters) this.setParameters(parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets GROUP BY condition in the query builder.\r\n     * If you had previously GROUP BY expression defined,\r\n     * calling this function will override previously set GROUP BY conditions.\r\n     */\r\n    groupBy(): this;\r\n\r\n    /**\r\n     * Sets GROUP BY condition in the query builder.\r\n     * If you had previously GROUP BY expression defined,\r\n     * calling this function will override previously set GROUP BY conditions.\r\n     */\r\n    groupBy(groupBy: string): this;\r\n\r\n    /**\r\n     * Sets GROUP BY condition in the query builder.\r\n     * If you had previously GROUP BY expression defined,\r\n     * calling this function will override previously set GROUP BY conditions.\r\n     */\r\n    groupBy(groupBy?: string): this {\r\n        if (groupBy) {\r\n            this.expressionMap.groupBys = [groupBy];\r\n        } else {\r\n            this.expressionMap.groupBys = [];\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds GROUP BY condition in the query builder.\r\n     */\r\n    addGroupBy(groupBy: string): this {\r\n        this.expressionMap.groupBys.push(groupBy);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     *\r\n     * Calling order by without order set will remove all previously set order bys.\r\n     */\r\n    orderBy(): this;\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     */\r\n    orderBy(sort: string, order?: \"ASC\"|\"DESC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this;\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     */\r\n    orderBy(order: OrderByCondition): this;\r\n\r\n    /**\r\n     * Sets ORDER BY condition in the query builder.\r\n     * If you had previously ORDER BY expression defined,\r\n     * calling this function will override previously set ORDER BY conditions.\r\n     */\r\n    orderBy(sort?: string|OrderByCondition, order: \"ASC\"|\"DESC\" = \"ASC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this {\r\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\r\n            throw new Error(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\r\n        if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\")\r\n            throw new Error(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\r\n\r\n        if (sort) {\r\n            if (sort instanceof Object) {\r\n                this.expressionMap.orderBys = sort as OrderByCondition;\r\n            } else {\r\n                if (nulls) {\r\n                    this.expressionMap.orderBys = { [sort as string]: { order, nulls } };\r\n                } else {\r\n                    this.expressionMap.orderBys = { [sort as string]: order };\r\n                }\r\n            }\r\n        } else {\r\n            this.expressionMap.orderBys = {};\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds ORDER BY condition in the query builder.\r\n     */\r\n    addOrderBy(sort: string, order: \"ASC\"|\"DESC\" = \"ASC\", nulls?: \"NULLS FIRST\"|\"NULLS LAST\"): this {\r\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\r\n            throw new Error(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\r\n        if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\")\r\n            throw new Error(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\r\n\r\n        if (nulls) {\r\n            this.expressionMap.orderBys[sort] = { order, nulls };\r\n        } else {\r\n            this.expressionMap.orderBys[sort] = order;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set's LIMIT - maximum number of rows to be selected.\r\n     * NOTE that it may not work as you expect if you are using joins.\r\n     * If you want to implement pagination, and you are having join in your query,\r\n     * then use instead take method instead.\r\n     */\r\n    limit(limit?: number): this {\r\n        this.expressionMap.limit = this.normalizeNumber(limit);\r\n        if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit))\r\n            throw new Error(`Provided \"limit\" value is not a number. Please provide a numeric value.`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set's OFFSET - selection offset.\r\n     * NOTE that it may not work as you expect if you are using joins.\r\n     * If you want to implement pagination, and you are having join in your query,\r\n     * then use instead skip method instead.\r\n     */\r\n    offset(offset?: number): this {\r\n        this.expressionMap.offset = this.normalizeNumber(offset);\r\n        if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset))\r\n            throw new Error(`Provided \"offset\" value is not a number. Please provide a numeric value.`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets maximal number of entities to take.\r\n     */\r\n    take(take?: number): this {\r\n        this.expressionMap.take = this.normalizeNumber(take);\r\n        if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take))\r\n            throw new Error(`Provided \"take\" value is not a number. Please provide a numeric value.`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets number of entities to skip.\r\n     */\r\n    skip(skip?: number): this {\r\n        this.expressionMap.skip = this.normalizeNumber(skip);\r\n        if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip))\r\n            throw new Error(`Provided \"skip\" value is not a number. Please provide a numeric value.`);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets locking mode.\r\n     */\r\n    setLock(lockMode: \"optimistic\", lockVersion: number): this;\r\n\r\n    /**\r\n     * Sets locking mode.\r\n     */\r\n    setLock(lockMode: \"optimistic\", lockVersion: Date): this;\r\n\r\n    /**\r\n     * Sets locking mode.\r\n     */\r\n    setLock(lockMode: \"pessimistic_read\"|\"pessimistic_write\"): this;\r\n\r\n    /**\r\n     * Sets locking mode.\r\n     */\r\n    setLock(lockMode: \"optimistic\"|\"pessimistic_read\"|\"pessimistic_write\", lockVersion?: number|Date): this {\r\n        this.expressionMap.lockMode = lockMode;\r\n        this.expressionMap.lockVersion = lockVersion;\r\n        return this;\r\n\r\n    }\r\n\r\n    /**\r\n     * Gets first raw result returned by execution of generated query builder sql.\r\n     */\r\n    async getRawOne(): Promise<any> {\r\n        return (await this.getRawMany())[0];\r\n    }\r\n\r\n    /**\r\n     * Gets all raw results returned by execution of generated query builder sql.\r\n     */\r\n    async getRawMany(): Promise<any[]> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError();\r\n\r\n        this.expressionMap.queryEntity = false;\r\n        const queryRunner = this.obtainQueryRunner();\r\n        try {\r\n            return await this.loadRawResults(queryRunner);\r\n\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) { // means we created our own query runner\r\n                await queryRunner.release();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\r\n     */\r\n    async getRawAndEntities(): Promise<{ entities: Entity[], raw: any[] }> {\r\n        const queryRunner = this.obtainQueryRunner();\r\n        try {\r\n            this.expressionMap.queryEntity = true;\r\n            return await this.executeEntitiesAndRawResults(queryRunner);\r\n\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\r\n                await queryRunner.release();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets single entity returned by execution of generated query builder sql.\r\n     */\r\n    async getOne(): Promise<Entity|undefined> {\r\n        const results = await this.getRawAndEntities();\r\n        const result = results.entities[0] as any;\r\n\r\n        if (result && this.expressionMap.lockMode === \"optimistic\" && this.expressionMap.lockVersion) {\r\n            const metadata = this.expressionMap.mainAlias!.metadata;\r\n\r\n            if (this.expressionMap.lockVersion instanceof Date) {\r\n                const actualVersion = result[metadata.updateDateColumn!.propertyName]; // what if columns arent set?\r\n                if (actualVersion.getTime() !== this.expressionMap.lockVersion.getTime())\r\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\r\n\r\n            } else {\r\n                const actualVersion = result[metadata.versionColumn!.propertyName]; // what if columns arent set?\r\n                if (actualVersion !== this.expressionMap.lockVersion)\r\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gets entities returned by execution of generated query builder sql.\r\n     */\r\n    async getMany(): Promise<Entity[]> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError();\r\n\r\n        const results = await this.getRawAndEntities();\r\n        return results.entities;\r\n    }\r\n\r\n    /**\r\n     * Gets count - number of entities selected by sql generated by this query builder.\r\n     * Count excludes all limitations set by setFirstResult and setMaxResults methods call.\r\n     */\r\n    async getCount(): Promise<number> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError();\r\n\r\n        const queryRunner = this.obtainQueryRunner();\r\n        try {\r\n            return await this.executeCountQuery(queryRunner);\r\n\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\r\n                await queryRunner.release();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\r\n     * This method is useful to build pagination.\r\n     */\r\n    async getManyAndCount(): Promise<[Entity[], number]> {\r\n        if (this.expressionMap.lockMode === \"optimistic\")\r\n            throw new OptimisticLockCanNotBeUsedError();\r\n\r\n        const queryRunner = this.obtainQueryRunner();\r\n        try {\r\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);\r\n            const count = await this.executeCountQuery(queryRunner);\r\n            return [entitiesAndRaw.entities, count];\r\n\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\r\n                await queryRunner.release();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes built SQL query and returns raw data stream.\r\n     */\r\n    async stream(): Promise<ReadStream> {\r\n        this.expressionMap.queryEntity = false;\r\n        const [sql, parameters] = this.getQueryAndParameters();\r\n        const queryRunner = this.obtainQueryRunner();\r\n        try {\r\n            const releaseFn = () => {\r\n                if (queryRunner !== this.queryRunner) // means we created our own query runner\r\n                    return queryRunner.release();\r\n                return;\r\n            };\r\n            return queryRunner.stream(sql, parameters, releaseFn, releaseFn);\r\n\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) // means we created our own query runner\r\n                await queryRunner.release();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables or disables query result caching.\r\n     */\r\n    cache(enabled: boolean): this;\r\n\r\n    /**\r\n     * Enables query result caching and sets in milliseconds in which cache will expire.\r\n     * If not set then global caching time will be used.\r\n     */\r\n    cache(milliseconds: number): this;\r\n\r\n    /**\r\n     * Enables query result caching and sets cache id and milliseconds in which cache will expire.\r\n     */\r\n    cache(id: any, milliseconds?: number): this;\r\n\r\n    /**\r\n     * Enables or disables query result caching.\r\n     */\r\n    cache(enabledOrMillisecondsOrId: boolean|number|string, maybeMilliseconds?: number): this {\r\n\r\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\r\n            this.expressionMap.cache = enabledOrMillisecondsOrId;\r\n\r\n        } else if (typeof enabledOrMillisecondsOrId === \"number\") {\r\n            this.expressionMap.cache = true;\r\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\r\n\r\n        } else if (typeof enabledOrMillisecondsOrId === \"string\" || typeof enabledOrMillisecondsOrId === \"number\") {\r\n            this.expressionMap.cache = true;\r\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId;\r\n        }\r\n\r\n        if (maybeMilliseconds) {\r\n            this.expressionMap.cacheDuration = maybeMilliseconds;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    protected join(direction: \"INNER\"|\"LEFT\",\r\n                   entityOrProperty: Function|string|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>),\r\n                   aliasName: string,\r\n                   condition?: string,\r\n                   parameters?: ObjectLiteral,\r\n                   mapToProperty?: string,\r\n                   isMappingMany?: boolean): void {\r\n\r\n        this.setParameters(parameters || {});\r\n\r\n        const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\r\n        joinAttribute.direction = direction;\r\n        joinAttribute.mapToProperty = mapToProperty;\r\n        joinAttribute.isMappingMany = isMappingMany;\r\n        joinAttribute.entityOrProperty = entityOrProperty; // relationName\r\n        joinAttribute.condition = condition; // joinInverseSideCondition\r\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\r\n        this.expressionMap.joinAttributes.push(joinAttribute);\r\n\r\n        if (joinAttribute.metadata) {\r\n\r\n            // todo: find and set metadata right there?\r\n            joinAttribute.alias = this.expressionMap.createAlias({\r\n                type: \"join\",\r\n                name: aliasName,\r\n                metadata: joinAttribute.metadata\r\n            });\r\n            if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\r\n                this.expressionMap.createAlias({\r\n                    type: \"join\",\r\n                    name: joinAttribute.junctionAlias,\r\n                    metadata: joinAttribute.relation.junctionEntityMetadata\r\n                });\r\n            }\r\n\r\n        } else {\r\n            let subQuery: string = \"\";\r\n            if (entityOrProperty instanceof Function) {\r\n                const subQueryBuilder: SelectQueryBuilder<any> = (entityOrProperty as any)(((this as any) as SelectQueryBuilder<any>).subQuery());\r\n                this.setParameters(subQueryBuilder.getParameters());\r\n                subQuery = subQueryBuilder.getQuery();\r\n\r\n            } else {\r\n                subQuery = entityOrProperty;\r\n            }\r\n            const isSubQuery = entityOrProperty instanceof Function || entityOrProperty.substr(0, 1) === \"(\" && entityOrProperty.substr(-1) === \")\";\r\n            joinAttribute.alias = this.expressionMap.createAlias({\r\n                type: \"join\",\r\n                name: aliasName,\r\n                tablePath: isSubQuery === false ? entityOrProperty as string : undefined,\r\n                subQuery: isSubQuery === true ? subQuery : undefined,\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates \"SELECT FROM\" part of SQL query.\r\n     */\r\n    protected createSelectExpression() {\r\n\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new Error(\"Cannot build query because main alias is not set (call qb#from method)\");\r\n\r\n        // todo throw exception if selects or from is missing\r\n\r\n        const allSelects: SelectQuery[] = [];\r\n        const excludedSelects: SelectQuery[] = [];\r\n\r\n        if (this.expressionMap.mainAlias.hasMetadata) {\r\n            const metadata = this.expressionMap.mainAlias.metadata;\r\n            allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\r\n            excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\r\n        }\r\n\r\n        // add selects from joins\r\n        this.expressionMap.joinAttributes\r\n            .forEach(join => {\r\n                if (join.metadata) {\r\n                    allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name!, join.metadata));\r\n                    excludedSelects.push(...this.findEntityColumnSelects(join.alias.name!, join.metadata));\r\n                } else {\r\n                    const hasMainAlias = this.expressionMap.selects.some(select => select.selection === join.alias.name);\r\n                    if (hasMainAlias) {\r\n                        allSelects.push({ selection: this.escape(join.alias.name!) + \".*\" });\r\n                        const excludedSelect = this.expressionMap.selects.find(select => select.selection === join.alias.name);\r\n                        excludedSelects.push(excludedSelect!);\r\n                    }\r\n                }\r\n            });\r\n\r\n        if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias.hasMetadata) {\r\n            const metadata = this.expressionMap.mainAlias.metadata;\r\n            if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === \"class-table\" && metadata.parentIdColumns) {\r\n                const alias = \"parentIdColumn_\" + metadata.parentEntityMetadata.tableName;\r\n                metadata.parentEntityMetadata.columns.forEach(column => {\r\n                    // TODO implement partial select\r\n                    allSelects.push({ selection: this.escape(alias) + \".\" + this.escape(column.databaseName), aliasName: alias + \"_\" + column.databaseName });\r\n                });\r\n            }\r\n        }\r\n\r\n        // add selects from relation id joins\r\n        // this.relationIdAttributes.forEach(relationIdAttr => {\r\n        // });\r\n\r\n        /*if (this.enableRelationIdValues) {\r\n         const parentMetadata = this.aliasMap.getEntityMetadataByAlias(this.aliasMap.mainAlias);\r\n         if (!parentMetadata)\r\n         throw new Error(\"Cannot get entity metadata for the given alias \" + this.aliasMap.mainAlias.name);\r\n\r\n         const metadata = this.connection.entityMetadatas.findByTarget(this.aliasMap.mainAlias.target);\r\n         metadata.manyToManyRelations.forEach(relation => {\r\n\r\n         const junctionMetadata = relation.junctionEntityMetadata;\r\n         junctionMetadata.columns.forEach(column => {\r\n         const select = ea(this.aliasMap.mainAlias.name + \"_\" + junctionMetadata.table.name + \"_ids\") + \".\" +\r\n         ec(column.name) + \" AS \" +\r\n         ea(this.aliasMap.mainAlias.name + \"_\" + relation.name + \"_ids_\" + column.name);\r\n         allSelects.push(select);\r\n         });\r\n         });\r\n         }*/\r\n\r\n        // add all other selects\r\n        this.expressionMap.selects\r\n            .filter(select => excludedSelects.indexOf(select) === -1)\r\n            .forEach(select => allSelects.push({ selection: this.replacePropertyNames(select.selection), aliasName: select.aliasName }));\r\n\r\n        // if still selection is empty, then simply set it to all (*)\r\n        if (allSelects.length === 0)\r\n            allSelects.push({ selection: \"*\" });\r\n\r\n        let lock: string = \"\";\r\n        if (this.connection.driver instanceof SqlServerDriver) {\r\n            switch (this.expressionMap.lockMode) {\r\n                case \"pessimistic_read\":\r\n                    lock = \" WITH (HOLDLOCK, ROWLOCK)\";\r\n                    break;\r\n                case \"pessimistic_write\":\r\n                    lock = \" WITH (UPDLOCK, ROWLOCK)\";\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // create a selection query\r\n        const froms = this.expressionMap.aliases\r\n            .filter(alias => alias.type === \"from\" && (alias.tablePath || alias.subQuery))\r\n            .map(alias => {\r\n                if (alias.subQuery)\r\n                    return alias.subQuery + \" \" + this.escape(alias.name);\r\n\r\n                return this.getTableName(alias.tablePath!) + \" \" + this.escape(alias.name);\r\n            });\r\n        const selection = allSelects.map(select => select.selection + (select.aliasName ? \" AS \" + this.escape(select.aliasName) : \"\")).join(\", \");\r\n        if ((this.expressionMap.limit || this.expressionMap.offset) && this.connection.driver instanceof OracleDriver)\r\n            return \"SELECT ROWNUM \" + this.escape(\"RN\") + \",\" + selection + \" FROM \" + froms.join(\", \") + lock;\r\n\r\n        return \"SELECT \" + selection + \" FROM \" + froms.join(\", \") + lock;\r\n    }\r\n\r\n    /**\r\n     * Creates \"JOIN\" part of SQL query.\r\n     */\r\n    protected createJoinExpression(): string {\r\n\r\n        // examples:\r\n        // select from owning side\r\n        // qb.select(\"post\")\r\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\r\n        // select from non-owning side\r\n        // qb.select(\"category\")\r\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\r\n\r\n        const joins = this.expressionMap.joinAttributes.map(joinAttr => {\r\n\r\n            const relation = joinAttr.relation;\r\n            const destinationTableName = joinAttr.tablePath;\r\n            const destinationTableAlias = joinAttr.alias.name;\r\n            const appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\r\n            const parentAlias = joinAttr.parentAlias;\r\n\r\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\r\n            // table to join, without junction table involved. This means we simply join direct table.\r\n            if (!parentAlias || !relation) {\r\n                const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);\r\n                return \" \" + joinAttr.direction + \" JOIN \" + destinationJoin + \" \" + this.escape(destinationTableAlias) +\r\n                    (joinAttr.condition ? \" ON \" + this.replacePropertyNames(joinAttr.condition) : \"\");\r\n            }\r\n\r\n            // if real entity relation is involved\r\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\r\n\r\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\r\n                const condition = relation.joinColumns.map(joinColumn => {\r\n                    return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\r\n                        parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath;\r\n                }).join(\" AND \");\r\n\r\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\r\n\r\n            } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\r\n\r\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\r\n                const condition = relation.inverseRelation!.joinColumns.map(joinColumn => {\r\n                    return destinationTableAlias + \".\" + relation.inverseRelation!.propertyPath + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" +\r\n                        parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\r\n                }).join(\" AND \");\r\n\r\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\r\n\r\n            } else { // means many-to-many\r\n                const junctionTableName = relation.junctionEntityMetadata!.tablePath;\r\n\r\n                const junctionAlias = joinAttr.junctionAlias;\r\n                let junctionCondition = \"\", destinationCondition = \"\";\r\n\r\n                if (relation.isOwning) {\r\n\r\n                    junctionCondition = relation.joinColumns.map(joinColumn => {\r\n                        // `post_category`.`postId` = `post`.`id`\r\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\r\n                    }).join(\" AND \");\r\n\r\n                    destinationCondition = relation.inverseJoinColumns.map(joinColumn => {\r\n                        // `category`.`id` = `post_category`.`categoryId`\r\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\r\n                    }).join(\" AND \");\r\n\r\n                } else {\r\n                    junctionCondition = relation.inverseRelation!.inverseJoinColumns.map(joinColumn => {\r\n                        // `post_category`.`categoryId` = `category`.`id`\r\n                        return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn!.propertyPath;\r\n                    }).join(\" AND \");\r\n\r\n                    destinationCondition = relation.inverseRelation!.joinColumns.map(joinColumn => {\r\n                        // `post`.`id` = `post_category`.`postId`\r\n                        return destinationTableAlias + \".\" + joinColumn.referencedColumn!.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\r\n                    }).join(\" AND \");\r\n                }\r\n\r\n                return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(junctionTableName) + \" \" + this.escape(junctionAlias) + \" ON \" + this.replacePropertyNames(junctionCondition) +\r\n                    \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + \" ON \" + this.replacePropertyNames(destinationCondition + appendedCondition);\r\n\r\n            }\r\n        });\r\n\r\n        if (!this.expressionMap.ignoreParentTablesJoins && this.expressionMap.mainAlias!.hasMetadata) {\r\n            const metadata = this.expressionMap.mainAlias!.metadata;\r\n            if (metadata.parentEntityMetadata && metadata.parentEntityMetadata.inheritanceType === \"class-table\" && metadata.parentIdColumns) {\r\n                const alias = \"parentIdColumn_\" + metadata.parentEntityMetadata.tableName;\r\n                const condition = metadata.parentIdColumns.map(parentIdColumn => {\r\n                    return this.expressionMap.mainAlias!.name + \".\" + parentIdColumn.propertyPath + \" = \" + this.escape(alias) + \".\" + this.escape(parentIdColumn.referencedColumn!.propertyPath);\r\n                }).join(\" AND \");\r\n                const join = \" JOIN \" + this.getTableName(metadata.parentEntityMetadata.tablePath) + \" \" + this.escape(alias) + \" ON \" + this.replacePropertyNames(condition);\r\n                joins.push(join);\r\n            }\r\n        }\r\n\r\n        return joins.join(\" \");\r\n    }\r\n\r\n    /**\r\n     * Creates \"GROUP BY\" part of SQL query.\r\n     */\r\n    protected createGroupByExpression() {\r\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\r\n        return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\r\n    }\r\n\r\n    /**\r\n     * Creates \"ORDER BY\" part of SQL query.\r\n     */\r\n    protected createOrderByExpression() {\r\n        const orderBys = this.expressionMap.allOrderBys;\r\n        if (Object.keys(orderBys).length > 0)\r\n            return \" ORDER BY \" + Object.keys(orderBys)\r\n                    .map(columnName => {\r\n                        if (typeof orderBys[columnName] === \"string\") {\r\n                            return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\r\n                        } else {\r\n                            return this.replacePropertyNames(columnName) + \" \" + (orderBys[columnName] as any).order + \" \" + (orderBys[columnName] as any).nulls;\r\n                        }\r\n                    })\r\n                    .join(\", \");\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query for Oracle database.\r\n     */\r\n    protected createLimitOffsetOracleSpecificExpression(sql: string): string {\r\n        if ((this.expressionMap.offset || this.expressionMap.limit) && this.connection.driver instanceof OracleDriver) {\r\n            sql = \"SELECT * FROM (\" + sql + \") WHERE \";\r\n            if (this.expressionMap.offset) {\r\n                sql += this.escape(\"RN\") + \" >= \" + this.expressionMap.offset;\r\n            }\r\n            if (this.expressionMap.limit) {\r\n                sql += (this.expressionMap.offset ? \" AND \" : \"\") + this.escape(\"RN\") + \" <= \" + ((this.expressionMap.offset || 0) + this.expressionMap.limit);\r\n            }\r\n        }\r\n        return sql;\r\n    }\r\n\r\n    /**\r\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\r\n     */\r\n    protected createLimitOffsetExpression(): string {\r\n        if (this.connection.driver instanceof OracleDriver)\r\n            return \"\";\r\n\r\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\r\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\r\n        let offset: number|undefined = this.expressionMap.offset,\r\n            limit: number|undefined = this.expressionMap.limit;\r\n        if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {\r\n            offset = this.expressionMap.skip;\r\n            limit = this.expressionMap.take;\r\n        }\r\n\r\n        if (this.connection.driver instanceof SqlServerDriver) {\r\n\r\n            if (limit && offset)\r\n                return \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\r\n            if (limit)\r\n                return \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\r\n            if (offset)\r\n                return \" OFFSET \" + offset + \" ROWS\";\r\n\r\n        } else if (this.connection.driver instanceof MysqlDriver) {\r\n\r\n            if (limit && offset)\r\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\r\n            if (limit)\r\n                return \" LIMIT \" + limit;\r\n            if (offset)\r\n                throw new OffsetWithoutLimitNotSupportedError(\"MySQL\");\r\n\r\n        } else if (this.connection.driver instanceof AbstractSqliteDriver) {\r\n\r\n            if (limit && offset)\r\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\r\n            if (limit)\r\n                return \" LIMIT \" + limit;\r\n            if (offset)\r\n                return \" LIMIT -1 OFFSET \" + offset;\r\n\r\n        } else {\r\n            if (limit && offset)\r\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\r\n            if (limit)\r\n                return \" LIMIT \" + limit;\r\n            if (offset)\r\n                return \" OFFSET \" + offset;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Creates \"LOCK\" part of SQL query.\r\n     */\r\n    protected createLockExpression(): string {\r\n        switch (this.expressionMap.lockMode) {\r\n            case \"pessimistic_read\":\r\n                if (this.connection.driver instanceof MysqlDriver) {\r\n                    return \" LOCK IN SHARE MODE\";\r\n\r\n                } else if (this.connection.driver instanceof PostgresDriver) {\r\n                    return \" FOR SHARE\";\r\n\r\n                } else if (this.connection.driver instanceof SqlServerDriver) {\r\n                    return \"\";\r\n\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError();\r\n                }\r\n            case \"pessimistic_write\":\r\n                if (this.connection.driver instanceof MysqlDriver || this.connection.driver instanceof PostgresDriver) {\r\n                    return \" FOR UPDATE\";\r\n\r\n                } else if (this.connection.driver instanceof SqlServerDriver) {\r\n                    return \"\";\r\n\r\n                } else {\r\n                    throw new LockNotSupportedOnGivenDriverError();\r\n                }\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates \"HAVING\" part of SQL query.\r\n     */\r\n    protected createHavingExpression() {\r\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\r\n        const conditions = this.expressionMap.havings.map((having, index) => {\r\n            switch (having.type) {\r\n                case \"and\":\r\n                    return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(having.condition);\r\n                case \"or\":\r\n                    return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(having.condition);\r\n                default:\r\n                    return this.replacePropertyNames(having.condition);\r\n            }\r\n        }).join(\" \");\r\n\r\n        if (!conditions.length) return \"\";\r\n        return \" HAVING \" + conditions;\r\n    }\r\n\r\n    protected buildEscapedEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\r\n        const hasMainAlias = this.expressionMap.selects.some(select => select.selection === aliasName);\r\n\r\n        const columns: ColumnMetadata[] = [];\r\n        if (hasMainAlias) {\r\n            columns.push(...metadata.columns.filter(column => column.isSelect === true));\r\n        }\r\n        columns.push(...metadata.columns.filter(column => {\r\n            return this.expressionMap.selects.some(select => select.selection === aliasName + \".\" + column.propertyName);\r\n        }));\r\n\r\n        // if user used partial selection and did not select some primary columns which are required to be selected\r\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\r\n        // to make entity contain exactly what user selected\r\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(primaryColumn => columns.indexOf(primaryColumn) === -1) : [];\r\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns];\r\n\r\n        return allColumns.map(column => {\r\n            const selection = this.expressionMap.selects.find(select => select.selection === aliasName + \".\" + column.propertyName);\r\n            return {\r\n                selection: this.escape(aliasName) + \".\" + this.escape(column.databaseName),\r\n                aliasName: selection && selection.aliasName ? selection.aliasName : aliasName + \"_\" + column.databaseName,\r\n                // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\r\n                virtual: selection ? selection.virtual === true : (hasMainAlias ? false : true),\r\n            };\r\n        });\r\n    }\r\n\r\n    protected findEntityColumnSelects(aliasName: string, metadata: EntityMetadata): SelectQuery[] {\r\n        const mainSelect = this.expressionMap.selects.find(select => select.selection === aliasName);\r\n        if (mainSelect)\r\n            return [mainSelect];\r\n\r\n        return this.expressionMap.selects.filter(select => {\r\n            return metadata.columns.some(column => select.selection === aliasName + \".\" + column.propertyName);\r\n        });\r\n    }\r\n\r\n    protected async executeCountQuery(queryRunner: QueryRunner): Promise<number> {\r\n        this.expressionMap.queryEntity = false;\r\n\r\n        const mainAlias = this.expressionMap.mainAlias!.name; // todo: will this work with \"fromTableName\"?\r\n        const metadata = this.expressionMap.mainAlias!.metadata;\r\n\r\n        const distinctAlias = this.escape(mainAlias);\r\n        let countSql: string = \"\";\r\n        if (metadata.hasMultiplePrimaryKeys) {\r\n            if (this.connection.driver instanceof AbstractSqliteDriver) {\r\n                countSql = `COUNT(DISTINCT(` + metadata.primaryColumns.map((primaryColumn, index) => {\r\n                    const propertyName = this.escape(primaryColumn.databaseName);\r\n                    return `${distinctAlias}.${propertyName}`;\r\n                }).join(\" || \") + \")) as \\\"cnt\\\"\";\r\n\r\n            } else {\r\n                countSql = `COUNT(DISTINCT(CONCAT(` + metadata.primaryColumns.map((primaryColumn, index) => {\r\n                    const propertyName = this.escape(primaryColumn.databaseName);\r\n                    return `${distinctAlias}.${propertyName}`;\r\n                }).join(\", \") + \"))) as \\\"cnt\\\"\";\r\n            }\r\n\r\n        } else {\r\n            countSql = `COUNT(DISTINCT(` + metadata.primaryColumns.map((primaryColumn, index) => {\r\n                const propertyName = this.escape(primaryColumn.databaseName);\r\n                return `${distinctAlias}.${propertyName}`;\r\n            }).join(\", \") + \")) as \\\"cnt\\\"\";\r\n        }\r\n\r\n        const results = await this.clone()\r\n            .mergeExpressionMap({ ignoreParentTablesJoins: true })\r\n            .orderBy()\r\n            .groupBy()\r\n            .offset(undefined)\r\n            .limit(undefined)\r\n            .skip(undefined)\r\n            .take(undefined)\r\n            .select(countSql)\r\n            .loadRawResults(queryRunner);\r\n\r\n        if (!results || !results[0] || !results[0][\"cnt\"])\r\n            return 0;\r\n\r\n        return parseInt(results[0][\"cnt\"]);\r\n    }\r\n\r\n    /**\r\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\r\n     */\r\n    protected async executeEntitiesAndRawResults(queryRunner: QueryRunner): Promise<{ entities: Entity[], raw: any[] }> {\r\n\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new Error(`Alias is not set. Use \"from\" method to set an alias.`);\r\n\r\n        if ((this.expressionMap.lockMode === \"pessimistic_read\" || this.expressionMap.lockMode === \"pessimistic_write\") && !queryRunner.isTransactionActive)\r\n            throw new PessimisticLockTransactionRequiredError();\r\n\r\n        if (this.expressionMap.lockMode === \"optimistic\") {\r\n            const metadata = this.expressionMap.mainAlias.metadata;\r\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\r\n                throw new NoVersionOrUpdateDateColumnError(metadata.name);\r\n        }\r\n\r\n        const broadcaster = new Broadcaster(this.connection);\r\n        const relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);\r\n        const relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);\r\n        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\r\n        relationIdMetadataTransformer.transform();\r\n        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\r\n        relationCountMetadataTransformer.transform();\r\n\r\n        let rawResults: any[] = [], entities: any[] = [];\r\n\r\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\r\n        // where we make two queries to find the data we need\r\n        // first query find ids in skip and take range\r\n        // and second query loads the actual data in given ids range\r\n        if ((this.expressionMap.skip || this.expressionMap.take) && this.expressionMap.joinAttributes.length > 0) {\r\n\r\n            // we are skipping order by here because its not working in subqueries anyway\r\n            // to make order by working we need to apply it on a distinct query\r\n            const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\r\n            const metadata = this.expressionMap.mainAlias.metadata;\r\n            const mainAliasName = this.expressionMap.mainAlias.name;\r\n\r\n            const querySelects = metadata.primaryColumns.map(primaryColumn => {\r\n                const distinctAlias = this.escape(\"distinctAlias\");\r\n                const columnAlias = this.escape(mainAliasName + \"_\" + primaryColumn.databaseName);\r\n                if (!orderBys[columnAlias]) // make sure we aren't overriding user-defined order in inverse direction\r\n                    orderBys[columnAlias] = \"ASC\";\r\n                return `${distinctAlias}.${columnAlias} as \"ids_${mainAliasName + \"_\" + primaryColumn.databaseName}\"`;\r\n            });\r\n\r\n            rawResults = await new SelectQueryBuilder(this.connection, queryRunner)\r\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\r\n                .addSelect(selects)\r\n                .from(`(${this.clone().orderBy().getQuery()})`, \"distinctAlias\")\r\n                .offset(this.expressionMap.skip)\r\n                .limit(this.expressionMap.take)\r\n                .orderBy(orderBys)\r\n                .cache(this.expressionMap.cache ? this.expressionMap.cache : this.expressionMap.cacheId, this.expressionMap.cacheDuration)\r\n                .setParameters(this.getParameters())\r\n                .getRawMany();\r\n\r\n            if (rawResults.length > 0) {\r\n                let condition = \"\";\r\n                const parameters: ObjectLiteral = {};\r\n                if (metadata.hasMultiplePrimaryKeys) {\r\n                    condition = rawResults.map((result, index) => {\r\n                        return metadata.primaryColumns.map(primaryColumn => {\r\n                            parameters[`ids_${index}_${primaryColumn.propertyName}`] = result[`ids_${mainAliasName}_${primaryColumn.databaseName}`];\r\n                            return `${mainAliasName}.${primaryColumn.propertyName}=:ids_${index}_${primaryColumn.databaseName}`;\r\n                        }).join(\" AND \");\r\n                    }).join(\" OR \");\r\n                } else {\r\n                    const ids = rawResults.map(result => result[\"ids_\" + mainAliasName + \"_\" + metadata.primaryColumns[0].databaseName]);\r\n                    const areAllNumbers = ids.every((id: any) => typeof id === \"number\");\r\n                    if (areAllNumbers) {\r\n                        // fixes #190. if all numbers then its safe to perform query without parameter\r\n                        condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyName} IN (${ids.join(\", \")})`;\r\n                    } else {\r\n                        parameters[\"ids\"] = ids;\r\n                        condition = mainAliasName + \".\" + metadata.primaryColumns[0].propertyName + \" IN (:ids)\";\r\n                    }\r\n                }\r\n                rawResults = await this.clone()\r\n                    .mergeExpressionMap({ extraAppendedAndWhereCondition: condition })\r\n                    .setParameters(parameters)\r\n                    .loadRawResults(queryRunner);\r\n            }\r\n\r\n        } else {\r\n            rawResults = await this.loadRawResults(queryRunner);\r\n        }\r\n\r\n        if (rawResults.length > 0) {\r\n\r\n            // transform raw results into entities\r\n            const rawRelationIdResults = await relationIdLoader.load(rawResults);\r\n            const rawRelationCountResults = await relationCountLoader.load(rawResults);\r\n            const transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults);\r\n            entities = transformer.transform(rawResults, this.expressionMap.mainAlias!);\r\n\r\n            // broadcast all \"after load\" events\r\n            if (this.expressionMap.mainAlias.hasMetadata)\r\n                await broadcaster.broadcastLoadEventsForAll(this.expressionMap.mainAlias.target, entities);\r\n        }\r\n\r\n        return {\r\n            raw: rawResults,\r\n            entities: entities,\r\n        };\r\n    }\r\n\r\n    protected createOrderByCombinedWithSelectExpression(parentAlias: string): [ string, OrderByCondition] {\r\n\r\n        // if table has a default order then apply it\r\n        const orderBys = this.expressionMap.allOrderBys;\r\n        const selectString = Object.keys(orderBys)\r\n            .map(orderCriteria => {\r\n                if (orderCriteria.indexOf(\".\") !== -1) {\r\n                    const [aliasName, propertyPath] = orderCriteria.split(\".\");\r\n                    const alias = this.expressionMap.findAliasByName(aliasName);\r\n                    const column = alias.metadata.findColumnWithPropertyName(propertyPath);\r\n                    return this.escape(parentAlias) + \".\" + this.escape(aliasName + \"_\" + column!.databaseName);\r\n                } else {\r\n                    if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria))\r\n                        return this.escape(parentAlias) + \".\" + orderCriteria;\r\n\r\n                    return \"\";\r\n                }\r\n            })\r\n            .join(\", \");\r\n\r\n        const orderByObject: OrderByCondition = {};\r\n        Object.keys(orderBys).forEach(orderCriteria => {\r\n            if (orderCriteria.indexOf(\".\") !== -1) {\r\n                const [aliasName, propertyPath] = orderCriteria.split(\".\");\r\n                const alias = this.expressionMap.findAliasByName(aliasName);\r\n                const column = alias.metadata.findColumnWithPropertyName(propertyPath);\r\n                orderByObject[this.escape(parentAlias) + \".\" + this.escape(aliasName + \"_\" + column!.databaseName)] = orderBys[orderCriteria];\r\n            } else {\r\n                if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) {\r\n                    orderByObject[this.escape(parentAlias) + \".\" + orderCriteria] = orderBys[orderCriteria];\r\n                } else {\r\n                    orderByObject[orderCriteria] = orderBys[orderCriteria];\r\n                }\r\n            }\r\n        });\r\n\r\n        return [selectString, orderByObject];\r\n    }\r\n\r\n    /**\r\n     * Loads raw results from the database.\r\n     */\r\n    protected async loadRawResults(queryRunner: QueryRunner) {\r\n        const [sql, parameters] = this.getQueryAndParameters();\r\n        const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\r\n        let savedQueryResultCacheOptions: QueryResultCacheOptions|undefined = undefined;\r\n        if (this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\r\n            savedQueryResultCacheOptions = await this.connection.queryResultCache.getFromCache({\r\n                identifier: this.expressionMap.cacheId,\r\n                query: this.getSql(),\r\n                duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000\r\n            }, queryRunner);\r\n            if (savedQueryResultCacheOptions && !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions))\r\n                return JSON.parse(savedQueryResultCacheOptions.result);\r\n        }\r\n\r\n        const results = await queryRunner.query(sql, parameters);\r\n\r\n        if (this.connection.queryResultCache && (this.expressionMap.cache || cacheOptions.alwaysEnabled)) {\r\n            await this.connection.queryResultCache.storeInCache({\r\n                identifier: this.expressionMap.cacheId,\r\n                query: this.getSql(),\r\n                time: new Date().getTime(),\r\n                duration: this.expressionMap.cacheDuration || cacheOptions.duration || 1000,\r\n                result: JSON.stringify(results)\r\n            }, savedQueryResultCacheOptions, queryRunner);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Merges into expression map given expression map properties.\r\n     */\r\n    protected mergeExpressionMap(expressionMap: Partial<QueryExpressionMap>): this {\r\n        Object.assign(this.expressionMap, expressionMap);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Normalizes a give number - converts to int if possible.\r\n     */\r\n    protected normalizeNumber(num: any) {\r\n        if (typeof num === \"number\" || num === undefined || num === null)\r\n            return num;\r\n\r\n        return Number(num);\r\n    }\r\n\r\n    /**\r\n     * Creates a query builder used to execute sql queries inside this query builder.\r\n     */\r\n    protected obtainQueryRunner() {\r\n        return this.queryRunner || this.connection.createQueryRunner(\"slave\");\r\n    }\r\n\r\n}\r\n"],"sourceRoot":".."}